---
phase: 04-integration-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - apps/api/src/repositories/webhook-queue.repository.ts
  - apps/api/src/repositories/processed-event.repository.ts
  - apps/api/src/services/webhook-queue.service.ts
  - apps/api/src/lib/webhook-verification.ts
  - apps/api/src/routes/webhooks/index.ts
  - apps/api/src/routes/webhooks/google.webhook.ts
  - apps/api/src/routes/webhooks/microsoft.webhook.ts
  - apps/api/src/routes/index.ts
  - firestore.rules
autonomous: true
requirements: [INFRA-03, INFRA-04, INFRA-05, INFRA-06]

must_haves:
  truths:
    - "Webhook endpoints exist for Google and Microsoft"
    - "Webhook signatures are verified before processing"
    - "Duplicate webhook events are handled idempotently"
    - "Firestore rules enforce organization isolation"
  artifacts:
    - path: "apps/api/src/lib/webhook-verification.ts"
      provides: "Signature verification functions per provider"
      exports: ["verifyGoogleWebhook", "verifyMicrosoftWebhook", "verifyHmacSignature"]
      min_lines: 40
    - path: "apps/api/src/repositories/webhook-queue.repository.ts"
      provides: "Queue operations for webhook processing"
      exports: ["webhookQueueRepository"]
    - path: "apps/api/src/repositories/processed-event.repository.ts"
      provides: "Idempotency tracking for processed webhook events"
      exports: ["processedEventRepository"]
    - path: "apps/api/src/services/webhook-queue.service.ts"
      provides: "Queue management with retry logic"
      exports: ["webhookQueueService"]
    - path: "apps/api/src/routes/webhooks/google.webhook.ts"
      provides: "Google Calendar webhook endpoint"
      exports: ["googleWebhook"]
    - path: "apps/api/src/routes/webhooks/microsoft.webhook.ts"
      provides: "Microsoft Graph webhook endpoint"
      exports: ["microsoftWebhook"]
    - path: "firestore.rules"
      provides: "Multi-tenant security rules"
      contains: "organizationId"
  key_links:
    - from: "apps/api/src/routes/webhooks/google.webhook.ts"
      to: "apps/api/src/lib/webhook-verification.ts"
      via: "signature verification"
      pattern: "verifyGoogleWebhook"
    - from: "apps/api/src/routes/webhooks/google.webhook.ts"
      to: "apps/api/src/services/webhook-queue.service.ts"
      via: "queue webhook for processing"
      pattern: "webhookQueueService\\.enqueue"
    - from: "apps/api/src/services/webhook-queue.service.ts"
      to: "apps/api/src/repositories/processed-event.repository.ts"
      via: "idempotency check"
      pattern: "processedEventRepository\\.findById"
    - from: "firestore.rules"
      to: "organizationId isolation"
      via: "security rule checks"
      pattern: "resource\\.data\\.organizationId"
---

<objective>
Create webhook infrastructure with signature verification, queue-based processing, and Firestore security rules.

Purpose: Webhooks from external providers (Google, Microsoft) need reliable processing with idempotency guarantees. Security rules provide defense-in-depth for multi-tenant isolation beyond application-layer checks.

Output:
- Webhook signature verification library
- Queue-based webhook processing (accept quickly, process async)
- Processed event repository for idempotency tracking
- Provider-specific webhook endpoints
- Firestore security rules for integrations and employees
</objective>

<execution_context>
@/Users/ardiansyahiqbal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ardiansyahiqbal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-integration-infrastructure/04-CONTEXT.md
@.planning/phases/04-integration-infrastructure/04-RESEARCH.md
@.planning/phases/04-integration-infrastructure/04-01-SUMMARY.md
@.planning/phases/04-integration-infrastructure/04-02-SUMMARY.md
@.planning/phases/02-plan-billing/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Webhook Verification Library, Queue, and Processed Event Repository</name>
  <files>apps/api/src/lib/webhook-verification.ts, apps/api/src/lib/index.ts, apps/api/src/repositories/webhook-queue.repository.ts, apps/api/src/repositories/processed-event.repository.ts, apps/api/src/repositories/index.ts, apps/api/src/services/webhook-queue.service.ts, apps/api/src/services/index.ts</files>
  <action>
Create webhook verification utilities, queue infrastructure, and processed event repository:

1. Create `apps/api/src/lib/webhook-verification.ts`:
```typescript
import crypto from "crypto";

/**
 * Google Calendar webhooks use a channel token for verification.
 * The token is set when creating the watch and included in each notification.
 */
export function verifyGoogleWebhook(
  channelToken: string | undefined,
  expectedToken: string
): boolean {
  if (!channelToken || !expectedToken) return false;
  try {
    return crypto.timingSafeEqual(
      Buffer.from(channelToken),
      Buffer.from(expectedToken)
    );
  } catch {
    return false;
  }
}

/**
 * Microsoft Graph webhooks use clientState for verification.
 * The clientState is set when creating the subscription.
 */
export function verifyMicrosoftWebhook(
  clientState: string | undefined,
  expectedState: string
): boolean {
  if (!clientState || !expectedState) return false;
  try {
    return crypto.timingSafeEqual(
      Buffer.from(clientState),
      Buffer.from(expectedState)
    );
  } catch {
    return false;
  }
}

/**
 * HMAC-SHA256 verification for providers that use it (BambooHR, Finch, Asana, ClickUp, Linear).
 * Some providers include timestamp in the signed payload.
 */
export function verifyHmacSignature(
  body: string,
  signature: string,
  secret: string,
  timestamp?: string
): boolean {
  let payload = body;
  if (timestamp) {
    payload = `${body}${timestamp}`;
  }

  const expectedSignature = crypto
    .createHmac("sha256", secret)
    .update(payload)
    .digest("hex");

  try {
    return crypto.timingSafeEqual(
      Buffer.from(signature),
      Buffer.from(expectedSignature)
    );
  } catch {
    return false;
  }
}

/**
 * BambooHR uses HMAC-SHA256 with timestamp for replay protection.
 */
export function verifyBambooHRWebhook(
  body: string,
  signature: string | undefined,
  timestamp: string | undefined,
  secret: string
): boolean {
  if (!signature || !timestamp) return false;

  // Check timestamp is within 5 minutes (300 seconds)
  const requestTime = parseInt(timestamp, 10);
  const now = Math.floor(Date.now() / 1000);
  if (Math.abs(now - requestTime) > 300) return false;

  return verifyHmacSignature(body + timestamp, signature, secret);
}
```

2. Update `apps/api/src/lib/index.ts`:
   - Export verification functions

3. Create `apps/api/src/repositories/processed-event.repository.ts`:
```typescript
import { firestore } from "@/lib/index.js";

export interface ProcessedEvent {
  id: string;           // Format: "{provider}:{eventId}"
  type: string;         // Provider name
  processedAt: string;  // ISO timestamp
}

const COLLECTION = "processed_events";

class ProcessedEventRepository {
  private collection = firestore.collection(COLLECTION);

  async findById(id: string): Promise<ProcessedEvent | null> {
    const doc = await this.collection.doc(id).get();
    if (!doc.exists) return null;
    return { id: doc.id, ...doc.data() } as ProcessedEvent;
  }

  async create(event: ProcessedEvent): Promise<ProcessedEvent> {
    await this.collection.doc(event.id).set({
      type: event.type,
      processedAt: event.processedAt,
    });
    return event;
  }

  async exists(id: string): Promise<boolean> {
    const doc = await this.collection.doc(id).get();
    return doc.exists;
  }

  // Cleanup events older than 7 days (called by scheduled function)
  async cleanupOldEvents(): Promise<number> {
    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();
    const snapshot = await this.collection
      .where("processedAt", "<", sevenDaysAgo)
      .limit(500)
      .get();

    const batch = firestore.batch();
    snapshot.docs.forEach((doc) => batch.delete(doc.ref));
    await batch.commit();

    return snapshot.size;
  }
}

export const processedEventRepository = new ProcessedEventRepository();
```

4. Create `apps/api/src/repositories/webhook-queue.repository.ts`:
```typescript
import { firestore } from "@/lib/index.js";

export type WebhookProvider =
  | "google"
  | "microsoft"
  | "bamboohr"
  | "finch"
  | "asana"
  | "clickup"
  | "linear";

export type QueueStatus = "pending" | "processing" | "completed" | "failed";

export interface WebhookQueueItem {
  id: string;
  provider: WebhookProvider;
  eventId: string;
  payload: string;             // Raw JSON payload
  headers: Record<string, string>;
  organizationId: string;
  status: QueueStatus;
  retryCount: number;
  maxRetries: number;
  nextRetryAt: string | null;
  lastError: string | null;
  createdAt: string;
  processedAt: string | null;
}

const COLLECTION = "webhook_queue";

class WebhookQueueRepository {
  private collection = firestore.collection(COLLECTION);

  async create(
    item: Omit<WebhookQueueItem, "id" | "createdAt" | "processedAt">
  ): Promise<WebhookQueueItem> {
    const doc = this.collection.doc();
    const data: Omit<WebhookQueueItem, "id"> = {
      ...item,
      createdAt: new Date().toISOString(),
      processedAt: null,
    };
    await doc.set(data);
    return { id: doc.id, ...data };
  }

  async findById(id: string): Promise<WebhookQueueItem | null> {
    const doc = await this.collection.doc(id).get();
    if (!doc.exists) return null;
    return { id: doc.id, ...doc.data() } as WebhookQueueItem;
  }

  async findPending(): Promise<WebhookQueueItem[]> {
    const snapshot = await this.collection
      .where("status", "==", "pending")
      .orderBy("createdAt", "asc")
      .limit(100)
      .get();
    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as WebhookQueueItem));
  }

  async findReadyForRetry(): Promise<WebhookQueueItem[]> {
    const now = new Date().toISOString();
    const snapshot = await this.collection
      .where("status", "==", "failed")
      .where("nextRetryAt", "<=", now)
      .where("retryCount", "<", 5)
      .limit(100)
      .get();
    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as WebhookQueueItem));
  }

  async markProcessing(id: string): Promise<void> {
    await this.collection.doc(id).update({ status: "processing" });
  }

  async markCompleted(id: string): Promise<void> {
    await this.collection.doc(id).update({
      status: "completed",
      processedAt: new Date().toISOString(),
    });
  }

  async markFailed(id: string, error: string): Promise<void> {
    const item = await this.findById(id);
    if (!item) return;

    const nextRetryAt = new Date(Date.now() + 30000).toISOString(); // 30 seconds
    await this.collection.doc(id).update({
      status: "failed",
      lastError: error,
      retryCount: item.retryCount + 1,
      nextRetryAt: item.retryCount + 1 < 5 ? nextRetryAt : null,
    });
  }
}

export const webhookQueueRepository = new WebhookQueueRepository();
```

5. Create `apps/api/src/services/webhook-queue.service.ts`:
```typescript
import { webhookQueueRepository, type WebhookProvider, type WebhookQueueItem } from "@/repositories/webhook-queue.repository.js";
import { processedEventRepository } from "@/repositories/processed-event.repository.js";

interface EnqueueInput {
  provider: WebhookProvider;
  eventId: string;
  payload: string;
  headers: Record<string, string>;
  organizationId: string;
}

class WebhookQueueService {
  async enqueue(input: EnqueueInput): Promise<WebhookQueueItem> {
    return webhookQueueRepository.create({
      provider: input.provider,
      eventId: input.eventId,
      payload: input.payload,
      headers: input.headers,
      organizationId: input.organizationId,
      status: "pending",
      retryCount: 0,
      maxRetries: 5,
      nextRetryAt: null,
      lastError: null,
    });
  }

  async process(item: WebhookQueueItem): Promise<void> {
    // Check idempotency - has this event already been processed?
    const existing = await processedEventRepository.findById(
      `${item.provider}:${item.eventId}`
    );
    if (existing) {
      console.log(`Event ${item.eventId} already processed, marking complete`);
      await webhookQueueRepository.markCompleted(item.id);
      return;
    }

    try {
      await webhookQueueRepository.markProcessing(item.id);

      // Process based on provider (actual processing in Phase 5/6/7)
      await this.processWebhook(item);

      // Mark as processed for idempotency
      await processedEventRepository.create({
        id: `${item.provider}:${item.eventId}`,
        type: item.provider,
        processedAt: new Date().toISOString(),
      });

      await webhookQueueRepository.markCompleted(item.id);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      console.error(`Failed to process webhook ${item.id}:`, errorMessage);
      await webhookQueueRepository.markFailed(item.id, errorMessage);
    }
  }

  private async processWebhook(item: WebhookQueueItem): Promise<void> {
    // Placeholder for actual processing - implemented in Phase 5/6/7
    switch (item.provider) {
      case "google":
        console.log(`Processing Google webhook: ${item.eventId}`);
        // TODO: Phase 5 - Calendar sync
        break;
      case "microsoft":
        console.log(`Processing Microsoft webhook: ${item.eventId}`);
        // TODO: Phase 5 - Calendar sync
        break;
      case "bamboohr":
      case "finch":
        console.log(`Processing HRIS webhook: ${item.eventId}`);
        // TODO: Phase 6 - Employee sync
        break;
      case "asana":
      case "clickup":
      case "linear":
        console.log(`Processing task webhook: ${item.eventId}`);
        // TODO: Phase 7 - Task sync
        break;
    }
  }
}

export const webhookQueueService = new WebhookQueueService();
```

6. Update index files:
   - Export webhookQueueRepository from repositories/index.ts
   - Export processedEventRepository from repositories/index.ts
   - Export webhookQueueService from services/index.ts
  </action>
  <verify>
```bash
cd apps/api && pnpm build
```
Build should pass. Verify exports:
```bash
cd apps/api && npx tsx -e "
import { verifyGoogleWebhook, verifyHmacSignature } from './src/lib/webhook-verification.js';
import { webhookQueueService } from './src/services/webhook-queue.service.js';
import { processedEventRepository } from './src/repositories/processed-event.repository.js';
console.log('Imports successful');
console.log('Google verify:', verifyGoogleWebhook('token', 'token'));
console.log('HMAC verify:', verifyHmacSignature('body', '', 'secret'));
"
```
  </verify>
  <done>
- Webhook verification functions for Google, Microsoft, HMAC
- Timing-safe comparisons used
- Queue repository with retry logic
- Processed event repository with findById and create methods
- Queue service with idempotency via processedEventRepository
- All exports working
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Webhook Routes for Google and Microsoft</name>
  <files>apps/api/src/routes/webhooks/google.webhook.ts, apps/api/src/routes/webhooks/microsoft.webhook.ts, apps/api/src/routes/webhooks/index.ts, apps/api/src/routes/index.ts</files>
  <action>
Create webhook endpoints that accept quickly and queue for processing:

1. Create `apps/api/src/routes/webhooks/google.webhook.ts`:
```typescript
import { Hono } from "hono";
import { verifyGoogleWebhook } from "@/lib/webhook-verification.js";
import { webhookQueueService } from "@/services/webhook-queue.service.js";
import { integrationRepository } from "@/repositories/index.js";

export const googleWebhook = new Hono();

googleWebhook.post("/", async (c) => {
  const channelId = c.req.header("X-Goog-Channel-ID");
  const channelToken = c.req.header("X-Goog-Channel-Token");
  const resourceState = c.req.header("X-Goog-Resource-State");
  const messageNumber = c.req.header("X-Goog-Message-Number");

  // Sync message on subscription creation - just acknowledge
  if (resourceState === "sync") {
    return c.text("", 200);
  }

  // Validate channel token exists
  if (!channelId || !channelToken) {
    console.error("Missing Google webhook headers");
    return c.text("Missing headers", 400);
  }

  // Find integration by channel ID to get expected token
  // Channel token format: {organizationId}:{secret}
  const [organizationId, secret] = channelToken.split(":");
  if (!organizationId || !secret) {
    console.error("Invalid channel token format");
    return c.text("Invalid token", 401);
  }

  // TODO: Verify against stored webhook secret in integration
  // For now, trust the token format (full verification in Phase 5)

  const body = await c.req.text();

  // Queue immediately - respond within 3 seconds per Google requirements
  await webhookQueueService.enqueue({
    provider: "google",
    eventId: `${channelId}-${messageNumber}`,
    payload: body,
    headers: {
      "X-Goog-Channel-ID": channelId,
      "X-Goog-Resource-State": resourceState || "",
      "X-Goog-Message-Number": messageNumber || "",
    },
    organizationId,
  });

  return c.text("", 200);
});
```

2. Create `apps/api/src/routes/webhooks/microsoft.webhook.ts`:
```typescript
import { Hono } from "hono";
import { verifyMicrosoftWebhook } from "@/lib/webhook-verification.js";
import { webhookQueueService } from "@/services/webhook-queue.service.js";

export const microsoftWebhook = new Hono();

// Microsoft Graph validation endpoint
microsoftWebhook.post("/", async (c) => {
  // Handle validation request from Microsoft
  const validationToken = c.req.query("validationToken");
  if (validationToken) {
    // Must respond with the token in plain text
    return c.text(validationToken, 200);
  }

  const body = await c.req.text();
  let payload: { value?: Array<{ clientState?: string; subscriptionId?: string; changeType?: string }> };

  try {
    payload = JSON.parse(body);
  } catch {
    console.error("Invalid Microsoft webhook JSON");
    return c.text("Invalid JSON", 400);
  }

  // Process each notification in the batch
  const notifications = payload.value || [];

  for (const notification of notifications) {
    const clientState = notification.clientState;
    const subscriptionId = notification.subscriptionId;

    if (!clientState || !subscriptionId) {
      console.error("Missing clientState or subscriptionId");
      continue;
    }

    // clientState format: {organizationId}:{secret}
    const [organizationId, secret] = clientState.split(":");
    if (!organizationId) {
      console.error("Invalid clientState format");
      continue;
    }

    // TODO: Verify against stored secret in integration (Phase 5)

    // Queue for processing
    await webhookQueueService.enqueue({
      provider: "microsoft",
      eventId: `${subscriptionId}-${notification.changeType}-${Date.now()}`,
      payload: JSON.stringify(notification),
      headers: {},
      organizationId,
    });
  }

  // Microsoft expects 202 Accepted
  return c.text("", 202);
});
```

3. Create `apps/api/src/routes/webhooks/index.ts`:
```typescript
import { Hono } from "hono";
import { googleWebhook } from "./google.webhook.js";
import { microsoftWebhook } from "./microsoft.webhook.js";

export const webhooksRoute = new Hono();

// Mount provider-specific webhook routes
webhooksRoute.route("/google", googleWebhook);
webhooksRoute.route("/microsoft", microsoftWebhook);

// Future providers will be added in Phase 6/7:
// webhooksRoute.route("/bamboohr", bamboohrWebhook);
// webhooksRoute.route("/finch", finchWebhook);
// webhooksRoute.route("/asana", asanaWebhook);
// webhooksRoute.route("/clickup", clickupWebhook);
// webhooksRoute.route("/linear", linearWebhook);
```

4. Update `apps/api/src/routes/index.ts`:
   - Import and mount webhooksRoute
   - Mount BEFORE auth middleware (like existing Stripe webhook)
   - Path: /webhooks (so full paths are /webhooks/google, /webhooks/microsoft)

Follow the pattern from existing webhook.route.ts for Stripe:
- Mounted before auth middleware
- Uses raw body where needed
  </action>
  <verify>
```bash
cd apps/api && pnpm build
```
Build should pass. Verify routes are mounted:
```bash
grep -n "webhooksRoute" apps/api/src/routes/index.ts
```
  </verify>
  <done>
- Google webhook accepts channel notifications, queues for processing
- Google webhook handles sync messages (subscription creation)
- Microsoft webhook handles validation requests
- Microsoft webhook processes notification batches
- Both routes mounted at /webhooks/{provider}
- Routes mounted before auth middleware
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Firestore Security Rules</name>
  <files>firestore.rules</files>
  <action>
Update Firestore security rules for multi-tenant isolation:

Replace the current permissive rules with organization-scoped rules:

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper: Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper: Get user's organization from custom claims
    function getUserOrgId() {
      return request.auth.token.organizationId;
    }

    // Helper: Check if document belongs to user's organization
    function isOrgMember(orgId) {
      return isAuthenticated() && getUserOrgId() == orgId;
    }

    // Helper: Check if user is org admin (owner or administrator)
    function isOrgAdmin(orgId) {
      return isOrgMember(orgId) &&
        request.auth.token.role in ['owner', 'administrator'];
    }

    // Users collection - users can read/write their own document
    match /users/{userId} {
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
    }

    // Organizations collection - members can read, admins can write
    match /organizations/{orgId} {
      allow read: if isOrgMember(orgId);
      allow write: if isOrgAdmin(orgId);
    }

    // Organization members - members can read, admins can manage
    match /organization_members/{memberId} {
      allow read: if isAuthenticated() &&
        (isOrgMember(resource.data.organizationId) ||
         request.auth.uid == resource.data.userId);
      allow create: if isOrgAdmin(request.resource.data.organizationId);
      allow update, delete: if isOrgAdmin(resource.data.organizationId);
    }

    // Employees - org members can read, admins can write
    match /employees/{employeeId} {
      allow read: if isOrgMember(resource.data.organizationId);
      allow create: if isOrgAdmin(request.resource.data.organizationId);
      allow update, delete: if isOrgAdmin(resource.data.organizationId);
    }

    // Integrations - org members can read, admins can manage
    match /integrations/{integrationId} {
      allow read: if isOrgMember(resource.data.organizationId);
      allow create: if isOrgAdmin(request.resource.data.organizationId);
      allow update, delete: if isOrgAdmin(resource.data.organizationId);
    }

    // Webhook queue - server-side only (no client access)
    match /webhook_queue/{queueId} {
      allow read, write: if false;
    }

    // Processed events - server-side only (no client access)
    // Note: processed_stripe_events kept separate for clarity
    match /processed_events/{eventId} {
      allow read, write: if false;
    }

    match /processed_stripe_events/{eventId} {
      allow read, write: if false;
    }

    // Newsletter signups - public create, admin read
    match /newsletter/{docId} {
      allow create: if true;
      allow read: if false; // Admin access via server only
    }

    // Tokens (refresh tokens, etc) - server-side only
    match /tokens/{tokenId} {
      allow read, write: if false;
    }
  }
}
```

Key rules per CONTEXT.md:
- All org members can see integration status (allow read: isOrgMember)
- Only org admins can manage integrations (allow write: isOrgAdmin)
- Employees readable by all org members, writable by admins
- Webhook queue and processed events are server-only
- organizationId field enforced on all tenant-scoped collections
  </action>
  <verify>
```bash
# Check rules syntax (if firebase-tools installed)
cd /Users/ardiansyahiqbal/dev-app/myx/klayim && npx firebase-tools emulators:exec --only firestore "echo 'Rules syntax valid'" 2>/dev/null || echo "Check manually"

# Verify key patterns exist
grep -c "organizationId" firestore.rules
grep -c "isOrgAdmin" firestore.rules
grep -c "isOrgMember" firestore.rules
```

Expected: organizationId appears 10+ times, isOrgAdmin 6+ times, isOrgMember 6+ times
  </verify>
  <done>
- Security rules enforce organizationId isolation
- Employees and integrations protected by org membership
- Webhook queue and processed events server-only
- Admin-only write access for sensitive collections
- Rules syntax is valid
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm build` passes in monorepo root
2. Webhook verification functions use timing-safe comparisons
3. Queue-based processing with idempotency
4. Provider-specific endpoints mounted at /webhooks/{provider}
5. Firestore rules enforce organization isolation
</verification>

<success_criteria>
- Webhook endpoints exist for Google and Microsoft
- Signatures verified before queuing (basic validation now, full in Phase 5)
- Idempotency via processed_events collection
- Queue-based async processing
- Firestore rules enforce multi-tenant isolation
- All org members can see integrations, only admins can manage
</success_criteria>

<output>
After completion, create `.planning/phases/04-integration-infrastructure/04-03-SUMMARY.md`
</output>
