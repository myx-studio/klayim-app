---
phase: 04-integration-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/api/src/repositories/integration.repository.ts
  - apps/api/src/repositories/employee.repository.ts
  - apps/api/src/repositories/index.ts
  - apps/api/src/services/token-refresh.service.ts
  - apps/api/src/services/integration.service.ts
  - apps/api/src/services/index.ts
autonomous: true
requirements: [INFRA-01, INFRA-02, INFRA-06]

must_haves:
  truths:
    - "OAuth tokens are encrypted before storage in Firestore"
    - "Expired tokens are refreshed automatically when accessed"
    - "Integration data is scoped by organizationId"
    - "Employee queries are scoped by organizationId"
  artifacts:
    - path: "apps/api/src/repositories/integration.repository.ts"
      provides: "Integration CRUD with encrypted credentials"
      exports: ["integrationRepository"]
      min_lines: 80
    - path: "apps/api/src/repositories/employee.repository.ts"
      provides: "Employee CRUD scoped by organization"
      exports: ["employeeRepository"]
      min_lines: 60
    - path: "apps/api/src/services/token-refresh.service.ts"
      provides: "Token refresh for Google and Microsoft"
      exports: ["tokenRefreshService"]
      min_lines: 100
    - path: "apps/api/src/services/integration.service.ts"
      provides: "Integration connect/disconnect logic"
      exports: ["integrationService"]
  key_links:
    - from: "apps/api/src/repositories/integration.repository.ts"
      to: "apps/api/src/lib/encryption.ts"
      via: "encrypt/decrypt for credentials"
      pattern: "import.*encrypt.*decrypt.*from.*encryption"
    - from: "apps/api/src/services/token-refresh.service.ts"
      to: "apps/api/src/repositories/integration.repository.ts"
      via: "read and update integration credentials"
      pattern: "integrationRepository\\.(findById|update)"
    - from: "apps/api/src/repositories/employee.repository.ts"
      to: "organizationId filter"
      via: "all queries scoped by org"
      pattern: "where\\(['\"]organizationId['\"]"
---

<objective>
Create repositories for integrations and employees, plus token refresh service.

Purpose: Integrations need secure credential storage with encryption, and all queries must be scoped by organization for multi-tenant isolation. Token refresh must happen automatically to maintain OAuth access without user intervention.

Output:
- Integration repository with encrypted credential storage
- Employee repository with org-scoped queries
- Token refresh service for Google and Microsoft OAuth
- Integration service for connect/disconnect
</objective>

<execution_context>
@/Users/ardiansyahiqbal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ardiansyahiqbal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-integration-infrastructure/04-CONTEXT.md
@.planning/phases/04-integration-infrastructure/04-RESEARCH.md
@.planning/phases/04-integration-infrastructure/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Integration and Employee Repositories</name>
  <files>apps/api/src/repositories/integration.repository.ts, apps/api/src/repositories/employee.repository.ts, apps/api/src/repositories/index.ts</files>
  <action>
Create repositories with organization scoping and encrypted credentials:

1. Create `apps/api/src/repositories/integration.repository.ts`:
```typescript
import { firestore } from "@/lib/index.js";
import { encrypt, decrypt } from "@/lib/encryption.js";
import type { Integration, EncryptedCredentials } from "@klayim/shared/types";

const COLLECTION = "integrations";

interface OAuthCredentials {
  accessToken: string;
  refreshToken: string;
  expiresAt?: string;
}

class IntegrationRepository {
  private collection = firestore.collection(COLLECTION);

  async create(
    integration: Omit<Integration, "id" | "credentials"> & { credentials: OAuthCredentials }
  ): Promise<Integration> {
    const masterKey = process.env.ENCRYPTION_KEY!;
    const encryptedCredentials = await encrypt(
      JSON.stringify(integration.credentials),
      masterKey
    );

    const doc = this.collection.doc();
    const data: Omit<Integration, "id"> = {
      ...integration,
      credentials: encryptedCredentials,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    await doc.set(data);
    return { id: doc.id, ...data };
  }

  async findById(id: string): Promise<Integration | null> {
    const doc = await this.collection.doc(id).get();
    if (!doc.exists) return null;
    return { id: doc.id, ...doc.data() } as Integration;
  }

  async findByOrganization(organizationId: string): Promise<Integration[]> {
    const snapshot = await this.collection
      .where("organizationId", "==", organizationId)
      .get();
    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as Integration));
  }

  async findByOrganizationAndProvider(
    organizationId: string,
    provider: string
  ): Promise<Integration[]> {
    const snapshot = await this.collection
      .where("organizationId", "==", organizationId)
      .where("provider", "==", provider)
      .get();
    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as Integration));
  }

  async findExpiringWithin(bufferMs: number): Promise<Integration[]> {
    const threshold = new Date(Date.now() + bufferMs).toISOString();
    const snapshot = await this.collection
      .where("status", "==", "connected")
      .where("expiresAt", "<=", threshold)
      .get();
    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as Integration));
  }

  async getDecryptedCredentials(integration: Integration): Promise<OAuthCredentials> {
    const masterKey = process.env.ENCRYPTION_KEY!;
    const decrypted = await decrypt(integration.credentials, masterKey);
    return JSON.parse(decrypted);
  }

  async update(id: string, data: Partial<Integration>): Promise<void> {
    await this.collection.doc(id).update({
      ...data,
      updatedAt: new Date().toISOString(),
    });
  }

  async updateCredentials(id: string, credentials: OAuthCredentials): Promise<void> {
    const masterKey = process.env.ENCRYPTION_KEY!;
    const encryptedCredentials = await encrypt(JSON.stringify(credentials), masterKey);
    await this.update(id, { credentials: encryptedCredentials });
  }

  async markAsError(id: string, error: string): Promise<void> {
    await this.update(id, { status: "error", lastError: error });
  }

  async markAsDisconnected(id: string): Promise<void> {
    await this.update(id, { status: "disconnected" });
  }

  async delete(id: string): Promise<void> {
    await this.collection.doc(id).delete();
  }
}

export const integrationRepository = new IntegrationRepository();
```

2. Create `apps/api/src/repositories/employee.repository.ts`:
```typescript
import { firestore } from "@/lib/index.js";
import type { Employee } from "@klayim/shared/types";

const COLLECTION = "employees";

class EmployeeRepository {
  private collection = firestore.collection(COLLECTION);

  async create(employee: Omit<Employee, "id">): Promise<Employee> {
    const doc = this.collection.doc();
    const data = {
      ...employee,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    await doc.set(data);
    return { id: doc.id, ...data };
  }

  async findById(id: string): Promise<Employee | null> {
    const doc = await this.collection.doc(id).get();
    if (!doc.exists) return null;
    return { id: doc.id, ...doc.data() } as Employee;
  }

  async findByOrganization(organizationId: string): Promise<Employee[]> {
    const snapshot = await this.collection
      .where("organizationId", "==", organizationId)
      .get();
    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as Employee));
  }

  async findByEmail(organizationId: string, email: string): Promise<Employee | null> {
    const snapshot = await this.collection
      .where("organizationId", "==", organizationId)
      .where("email", "==", email)
      .limit(1)
      .get();
    if (snapshot.empty) return null;
    return { id: snapshot.docs[0].id, ...snapshot.docs[0].data() } as Employee;
  }

  async findBySourceId(
    organizationId: string,
    sourceType: string,
    sourceId: string
  ): Promise<Employee | null> {
    const snapshot = await this.collection
      .where("organizationId", "==", organizationId)
      .where("sourceType", "==", sourceType)
      .where("sourceId", "==", sourceId)
      .limit(1)
      .get();
    if (snapshot.empty) return null;
    return { id: snapshot.docs[0].id, ...snapshot.docs[0].data() } as Employee;
  }

  async update(id: string, data: Partial<Employee>): Promise<void> {
    await this.collection.doc(id).update({
      ...data,
      updatedAt: new Date().toISOString(),
    });
  }

  async upsertBySourceId(
    organizationId: string,
    sourceType: string,
    sourceId: string,
    data: Omit<Employee, "id" | "createdAt" | "updatedAt">
  ): Promise<Employee> {
    const existing = await this.findBySourceId(organizationId, sourceType, sourceId);
    if (existing) {
      await this.update(existing.id, { ...data, lastSyncedAt: new Date().toISOString() });
      return { ...existing, ...data };
    }
    return this.create({ ...data, organizationId, sourceType, sourceId });
  }

  async delete(id: string): Promise<void> {
    await this.collection.doc(id).delete();
  }

  async deleteBySourceId(organizationId: string, sourceType: string, sourceId: string): Promise<void> {
    const employee = await this.findBySourceId(organizationId, sourceType, sourceId);
    if (employee) {
      await this.delete(employee.id);
    }
  }

  async getUniqueDepartments(organizationId: string): Promise<string[]> {
    const employees = await this.findByOrganization(organizationId);
    return [...new Set(employees.map((e) => e.department).filter(Boolean))];
  }

  async getUniqueRoles(organizationId: string): Promise<string[]> {
    const employees = await this.findByOrganization(organizationId);
    return [...new Set(employees.map((e) => e.role).filter(Boolean))];
  }
}

export const employeeRepository = new EmployeeRepository();
```

3. Update `apps/api/src/repositories/index.ts`:
   - Export integrationRepository
   - Export employeeRepository
  </action>
  <verify>
```bash
cd apps/api && pnpm build
```
Build should pass. Verify exports:
```bash
grep -E "export.*integrationRepository|export.*employeeRepository" apps/api/src/repositories/index.ts
```
  </verify>
  <done>
- Integration repository encrypts credentials on create
- Integration repository can find by org, provider, and expiry time
- Employee repository all queries include organizationId filter
- Both repositories exported from index.ts
- Build passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Token Refresh Service</name>
  <files>apps/api/src/services/token-refresh.service.ts, apps/api/src/services/index.ts</files>
  <action>
Create token refresh service with hybrid proactive/on-demand refresh:

1. Create `apps/api/src/services/token-refresh.service.ts`:

Key implementation:
- REFRESH_BUFFER_MS = 5 * 60 * 1000 (5 minutes before expiry)
- `getValidToken(integrationId)` - on-demand refresh if expired or expiring soon
- `refreshExpiringTokens()` - proactive batch refresh (called by scheduled function)
- `refreshToken(integrationId)` - actual refresh logic per provider

For Google (google_calendar):
- Use `googleapis` auth.OAuth2 client
- Call `oauth2Client.refreshAccessToken()`
- Extract new access_token and expiry

For Microsoft (microsoft_calendar):
- Use `@azure/msal-node` ConfidentialClientApplication
- Call `msalClient.acquireTokenByRefreshToken()`
- Extract accessToken and expiresOn

Error handling:
- On refresh failure: mark integration as 'error', store lastError
- Log error for admin notification (Phase 4 doesn't implement email yet)

Include tracking:
- Update lastRefreshedAt on success
- Increment refreshCount
- Update lastUsedAt when token is accessed

Note: googleapis and @azure/msal-node are NOT installed yet. The service should be structured correctly but actual OAuth refresh calls will be stubbed with TODO comments until Phase 5 installs the libraries. Check if installed first:
```bash
grep -q "googleapis" apps/api/package.json && echo "installed" || echo "not installed"
```

If not installed, create the service structure with TODO placeholders for the actual refresh calls.
  </action>
  <verify>
```bash
cd apps/api && pnpm build
```
Build should pass. Service should be importable:
```bash
cd apps/api && npx tsx -e "
import { tokenRefreshService } from './src/services/token-refresh.service.js';
console.log('Service imported, methods:', Object.keys(tokenRefreshService));
"
```
  </verify>
  <done>
- Token refresh service exports getValidToken and refreshExpiringTokens
- Service uses integration repository for credential read/update
- Service includes provider-specific refresh logic (or stubs)
- Error handling marks integration as error
- Usage tracking (lastUsedAt, refreshCount) implemented
- Build passes
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Integration Service</name>
  <files>apps/api/src/services/integration.service.ts, apps/api/src/services/index.ts</files>
  <action>
Create integration service for connect/disconnect operations:

1. Create `apps/api/src/services/integration.service.ts`:

Key methods:
- `connect(organizationId, provider, credentials, accountInfo)` - create new integration with encrypted credentials
- `disconnect(integrationId)` - mark as disconnected, keep synced data
- `getIntegrations(organizationId)` - list all integrations for org
- `getIntegrationsByProvider(organizationId, provider)` - for multi-account support

Implementation:
```typescript
import { integrationRepository } from "@/repositories/index.js";
import type { IntegrationProvider, Integration } from "@klayim/shared/types";

interface ConnectInput {
  organizationId: string;
  provider: IntegrationProvider;
  accountEmail: string;
  accountId: string;
  scopes: string[];
  accessToken: string;
  refreshToken: string;
  expiresAt: string;
}

class IntegrationService {
  async connect(input: ConnectInput): Promise<Integration> {
    // Check if same account already connected
    const existing = await integrationRepository.findByOrganizationAndProvider(
      input.organizationId,
      input.provider
    );
    const duplicate = existing.find((i) => i.accountEmail === input.accountEmail);
    if (duplicate) {
      throw new Error(`Account ${input.accountEmail} already connected`);
    }

    return integrationRepository.create({
      organizationId: input.organizationId,
      provider: input.provider,
      accountEmail: input.accountEmail,
      accountId: input.accountId,
      status: "connected",
      scopes: input.scopes,
      credentials: {
        accessToken: input.accessToken,
        refreshToken: input.refreshToken,
        expiresAt: input.expiresAt,
      },
      expiresAt: input.expiresAt,
      lastUsedAt: new Date().toISOString(),
      lastRefreshedAt: new Date().toISOString(),
      refreshCount: 0,
    });
  }

  async disconnect(integrationId: string): Promise<void> {
    // Per CONTEXT.md: one-click disconnect, keep synced data
    await integrationRepository.markAsDisconnected(integrationId);
  }

  async getIntegrations(organizationId: string): Promise<Integration[]> {
    return integrationRepository.findByOrganization(organizationId);
  }

  async getIntegrationsByProvider(
    organizationId: string,
    provider: IntegrationProvider
  ): Promise<Integration[]> {
    return integrationRepository.findByOrganizationAndProvider(organizationId, provider);
  }

  async getIntegration(integrationId: string): Promise<Integration | null> {
    return integrationRepository.findById(integrationId);
  }
}

export const integrationService = new IntegrationService();
```

2. Update `apps/api/src/services/index.ts`:
   - Export tokenRefreshService
   - Export integrationService
  </action>
  <verify>
```bash
cd apps/api && pnpm build
```
Build should pass. Services should be importable:
```bash
cd apps/api && npx tsx -e "
import { integrationService, tokenRefreshService } from './src/services/index.js';
console.log('Services imported');
"
```
  </verify>
  <done>
- Integration service handles connect with duplicate check
- Disconnect marks as disconnected (doesn't delete data)
- Multi-account support via getIntegrationsByProvider
- All services exported from index.ts
- Build passes
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm build` passes in monorepo root
2. Integration repository encrypts credentials using encryption lib
3. Employee repository queries all include organizationId
4. Token refresh service structure in place
5. Integration service handles connect/disconnect
</verification>

<success_criteria>
- OAuth credentials encrypted before Firestore storage
- Token refresh ready for provider-specific implementation
- All queries scoped by organizationId
- Multi-account support (multiple Google accounts per org)
- One-click disconnect preserves synced data
</success_criteria>

<output>
After completion, create `.planning/phases/04-integration-infrastructure/04-02-SUMMARY.md`
</output>
