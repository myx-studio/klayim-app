---
phase: 04-integration-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/lib/encryption.ts
  - packages/shared/src/types/integration.ts
  - packages/shared/src/types/employee.ts
  - packages/shared/src/types/index.ts
  - packages/shared/src/schemas/employee.schema.ts
  - packages/shared/src/schemas/index.ts
autonomous: true
requirements: [INFRA-01, INFRA-06]

must_haves:
  truths:
    - "OAuth tokens can be encrypted with AES-256-GCM before storage"
    - "Encrypted tokens can be decrypted back to original value"
    - "Each encryption produces unique ciphertext (fresh IV/salt)"
    - "Employee records are typed with organizationId for tenant isolation"
  artifacts:
    - path: "apps/api/src/lib/encryption.ts"
      provides: "AES-256-GCM encrypt/decrypt utilities"
      exports: ["encrypt", "decrypt"]
      min_lines: 50
    - path: "packages/shared/src/types/integration.ts"
      provides: "Integration and EncryptedCredentials types"
      exports: ["Integration", "IntegrationProvider", "IntegrationStatus", "EncryptedCredentials"]
    - path: "packages/shared/src/types/employee.ts"
      provides: "Employee type with organizationId"
      exports: ["Employee", "EmploymentStatus", "EmployeeSourceType"]
    - path: "packages/shared/src/schemas/employee.schema.ts"
      provides: "Zod validation schema for employees"
      exports: ["employeeSchema", "createEmployeeSchema"]
  key_links:
    - from: "apps/api/src/lib/encryption.ts"
      to: "process.env.ENCRYPTION_KEY"
      via: "environment variable for master key"
      pattern: "process\\.env\\.ENCRYPTION_KEY"
    - from: "packages/shared/src/types/employee.ts"
      to: "organizationId"
      via: "multi-tenant isolation field"
      pattern: "organizationId: string"
---

<objective>
Create foundational types and encryption utilities for integration infrastructure.

Purpose: All OAuth token storage requires encryption, and all data models need organizational scoping for multi-tenant isolation. This plan establishes the cryptographic foundation and type definitions that subsequent plans will use.

Output:
- AES-256-GCM encryption library with scrypt key derivation
- Integration types for OAuth token storage
- Employee types for HRIS data import
- Employee validation schema
</objective>

<execution_context>
@/Users/ardiansyahiqbal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ardiansyahiqbal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-integration-infrastructure/04-CONTEXT.md
@.planning/phases/04-integration-infrastructure/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AES-256-GCM Encryption Library</name>
  <files>apps/api/src/lib/encryption.ts, apps/api/src/lib/index.ts</files>
  <action>
Create encryption utilities using Node.js native crypto module:

1. Create `apps/api/src/lib/encryption.ts`:
   - Use AES-256-GCM algorithm (authenticated encryption)
   - IV_LENGTH = 12 bytes (96 bits for GCM)
   - SALT_LENGTH = 32 bytes
   - KEY_LENGTH = 32 bytes (256 bits)
   - Use `crypto.scrypt()` for key derivation from master key + salt
   - Export `encrypt(plaintext: string, masterKey: string): Promise<EncryptedData>`
   - Export `decrypt(data: EncryptedData, masterKey: string): Promise<string>`
   - Include `keyVersion: number` in EncryptedData for future key rotation
   - Get current key version from env (default to 1): `getCurrentKeyVersion()`

2. Update `apps/api/src/lib/index.ts`:
   - Export encrypt, decrypt from encryption.ts

Implementation notes:
- Always use `crypto.randomBytes()` for IV and salt (never reuse)
- Store IV, salt, authTag as base64 strings
- Use `crypto.timingSafeEqual` for any comparisons if needed
- Do NOT hardcode or log the master key
  </action>
  <verify>
Create a simple test in the file comments or run:
```bash
cd apps/api && npx tsx -e "
const { encrypt, decrypt } = require('./src/lib/encryption.ts');
const test = async () => {
  const key = 'test-key-32-chars-long-for-scrypt';
  const plaintext = 'secret-token-12345';
  const encrypted = await encrypt(plaintext, key);
  const decrypted = await decrypt(encrypted, key);
  console.log('Match:', decrypted === plaintext);
  console.log('Different ciphertext on re-encrypt:',
    (await encrypt(plaintext, key)).ciphertext !== encrypted.ciphertext);
};
test();
"
```
Both should output true. Build should pass: `pnpm build`
  </verify>
  <done>
- encrypt() produces EncryptedData with ciphertext, iv, authTag, salt, keyVersion
- decrypt() restores original plaintext
- Re-encrypting same plaintext produces different ciphertext (fresh IV/salt)
- Build passes without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Integration and Employee Types</name>
  <files>packages/shared/src/types/integration.ts, packages/shared/src/types/employee.ts, packages/shared/src/types/index.ts</files>
  <action>
Create type definitions for integrations and employees:

1. Create `packages/shared/src/types/integration.ts`:
```typescript
export type IntegrationProvider =
  | 'google_calendar'
  | 'microsoft_calendar'
  | 'bamboohr'
  | 'finch'
  | 'asana'
  | 'clickup'
  | 'linear';

export type IntegrationStatus = 'connected' | 'disconnected' | 'error' | 'refreshing';

export interface EncryptedCredentials {
  ciphertext: string;
  iv: string;
  authTag: string;
  salt: string;
  keyVersion: number;
}

export interface Integration {
  id: string;
  organizationId: string;
  provider: IntegrationProvider;
  accountEmail: string;        // For display and multi-account support
  accountId: string;           // Provider's user/account ID
  status: IntegrationStatus;
  scopes: string[];            // Granted OAuth scopes
  credentials: EncryptedCredentials;
  webhookChannelId?: string;   // For Google Calendar
  webhookSecret?: string;      // For webhook verification (encrypted)
  subscriptionId?: string;     // For Microsoft Graph
  expiresAt: string;           // Token expiry ISO string
  lastUsedAt: string;
  lastRefreshedAt: string;
  refreshCount: number;
  lastError?: string;
  createdAt: string;
  updatedAt: string;
}
```

2. Create `packages/shared/src/types/employee.ts`:
```typescript
export type EmploymentStatus = 'fullTime' | 'partTime' | 'contractor' | 'inactive';
export type EmployeeSourceType = 'bamboohr' | 'finch' | 'manual' | 'csv';

export interface Employee {
  id: string;
  organizationId: string;      // Multi-tenant isolation key

  // Required fields per CONTEXT.md
  name: string;
  email: string;               // For matching meeting attendees
  role: string;                // Free-form
  department: string;          // Free-form, single department
  hourlyRateCents: number;     // Integer, stored in cents

  // Status and source tracking
  employmentStatus: EmploymentStatus;
  sourceType: EmployeeSourceType;
  sourceId?: string;           // External ID from HRIS

  // Timestamps
  createdAt: string;
  updatedAt: string;
  lastSyncedAt?: string;
}
```

3. Update `packages/shared/src/types/index.ts`:
   - Export all types from integration.ts
   - Export all types from employee.ts
  </action>
  <verify>
```bash
cd packages/shared && pnpm build
```
Build should pass. Types should be importable:
```bash
cd apps/api && npx tsx -e "
import type { Integration, Employee } from '@klayim/shared/types';
console.log('Types imported successfully');
"
```
  </verify>
  <done>
- IntegrationProvider includes all 7 providers
- Integration type has organizationId field
- Employee type has hourlyRateCents as number (not float)
- Employee type has sourceType for tracking import source
- All types exportable from @klayim/shared/types
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Employee Validation Schema</name>
  <files>packages/shared/src/schemas/employee.schema.ts, packages/shared/src/schemas/index.ts</files>
  <action>
Create Zod validation schemas for employee data:

1. Create `packages/shared/src/schemas/employee.schema.ts`:
```typescript
import { z } from "zod";

export const employmentStatusSchema = z.enum(['fullTime', 'partTime', 'contractor', 'inactive']);
export const employeeSourceTypeSchema = z.enum(['bamboohr', 'finch', 'manual', 'csv']);

// Base employee schema (for API responses, includes id and timestamps)
export const employeeSchema = z.object({
  id: z.string(),
  organizationId: z.string(),
  name: z.string().min(1, "Name is required"),
  email: z.string().email("Valid email required"),
  role: z.string().min(1, "Role is required"),
  department: z.string().min(1, "Department is required"),
  hourlyRateCents: z.number().int().min(0, "Hourly rate must be non-negative"),
  employmentStatus: employmentStatusSchema,
  sourceType: employeeSourceTypeSchema,
  sourceId: z.string().optional(),
  createdAt: z.string(),
  updatedAt: z.string(),
  lastSyncedAt: z.string().optional(),
});

// Create employee schema (for manual add, without id/timestamps)
export const createEmployeeSchema = z.object({
  name: z.string().min(1, "Name is required"),
  email: z.string().email("Valid email required"),
  role: z.string().min(1, "Role is required"),
  department: z.string().min(1, "Department is required"),
  hourlyRateCents: z.number().int().min(0, "Hourly rate must be non-negative"),
  employmentStatus: employmentStatusSchema.default('fullTime'),
});

// Update employee schema (partial, for editing)
export const updateEmployeeSchema = createEmployeeSchema.partial();

// CSV import row schema (salary conversion handled in service)
export const csvEmployeeRowSchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
  role: z.string().optional().default(''),
  department: z.string().optional().default(''),
  hourlyRate: z.number().optional(),      // Will be converted to cents
  annualSalary: z.number().optional(),    // Alternative to hourlyRate
});

export type CreateEmployeeInput = z.infer<typeof createEmployeeSchema>;
export type UpdateEmployeeInput = z.infer<typeof updateEmployeeSchema>;
export type CsvEmployeeRow = z.infer<typeof csvEmployeeRowSchema>;
```

2. Update `packages/shared/src/schemas/index.ts`:
   - Export all schemas from employee.schema.ts
  </action>
  <verify>
```bash
cd packages/shared && pnpm build
```
Build should pass. Test schema validation:
```bash
cd apps/api && npx tsx -e "
import { createEmployeeSchema } from '@klayim/shared/schemas';
const valid = createEmployeeSchema.safeParse({
  name: 'John Doe',
  email: 'john@example.com',
  role: 'Engineer',
  department: 'Engineering',
  hourlyRateCents: 5000,
  employmentStatus: 'fullTime'
});
console.log('Valid:', valid.success);

const invalid = createEmployeeSchema.safeParse({
  name: 'John Doe',
  email: 'not-an-email',
  role: 'Engineer',
  department: 'Engineering',
  hourlyRateCents: -100,
});
console.log('Invalid caught:', !invalid.success);
"
```
  </verify>
  <done>
- createEmployeeSchema validates all required fields
- hourlyRateCents must be non-negative integer
- email must be valid format
- Build passes
- Schema exports work from @klayim/shared/schemas
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm build` passes in monorepo root
2. Encryption library can encrypt/decrypt round-trip
3. Types are importable in apps/api
4. Employee schema validates correctly
</verification>

<success_criteria>
- AES-256-GCM encryption with fresh IV/salt per encryption
- Integration type defines OAuth token storage structure
- Employee type has organizationId for multi-tenant isolation
- Employee hourlyRateCents is integer (cents, not dollars)
- All types and schemas exported from shared package
</success_criteria>

<output>
After completion, create `.planning/phases/04-integration-infrastructure/04-01-SUMMARY.md`
</output>
