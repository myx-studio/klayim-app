---
phase: 07-task-management-integration
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified:
  - apps/api/src/services/asana.service.ts
  - apps/api/src/services/clickup.service.ts
  - apps/api/src/services/linear.service.ts
  - apps/api/src/routes/oauth/asana.ts
  - apps/api/src/routes/oauth/clickup.ts
  - apps/api/src/routes/oauth/linear.ts
  - apps/api/src/routes/oauth/index.ts
  - apps/api/src/services/index.ts
  - apps/api/src/services/token-refresh.service.ts
autonomous: true
requirements: [TASK-01, TASK-02, TASK-03]

must_haves:
  truths:
    - "User can initiate Asana OAuth from /oauth/asana/authorize"
    - "User can initiate ClickUp OAuth from /oauth/clickup/authorize"
    - "User can initiate Linear OAuth from /oauth/linear/authorize"
    - "OAuth callbacks exchange codes for tokens and create integrations"
    - "Token refresh works for all three providers"
  artifacts:
    - path: "apps/api/src/services/asana.service.ts"
      provides: "Asana OAuth and task fetch service"
      exports: ["asanaService"]
    - path: "apps/api/src/services/clickup.service.ts"
      provides: "ClickUp OAuth and task fetch service"
      exports: ["clickupService"]
    - path: "apps/api/src/services/linear.service.ts"
      provides: "Linear OAuth and issue fetch service"
      exports: ["linearService"]
    - path: "apps/api/src/routes/oauth/asana.ts"
      provides: "Asana OAuth routes"
      exports: ["asanaOAuth"]
    - path: "apps/api/src/routes/oauth/clickup.ts"
      provides: "ClickUp OAuth routes"
      exports: ["clickupOAuth"]
    - path: "apps/api/src/routes/oauth/linear.ts"
      provides: "Linear OAuth routes"
      exports: ["linearOAuth"]
  key_links:
    - from: "apps/api/src/routes/oauth/asana.ts"
      to: "apps/api/src/services/asana.service.ts"
      via: "service import"
      pattern: "asanaService"
    - from: "apps/api/src/routes/oauth/clickup.ts"
      to: "apps/api/src/services/clickup.service.ts"
      via: "service import"
      pattern: "clickupService"
    - from: "apps/api/src/routes/oauth/linear.ts"
      to: "apps/api/src/services/linear.service.ts"
      via: "service import"
      pattern: "linearService"
---

<objective>
Create OAuth services and routes for Asana, ClickUp, and Linear task management providers

Purpose: Enable users to connect their task management tools via OAuth
Output: Three provider services with OAuth flows, OAuth routes mounted at /oauth/{provider}
</objective>

<execution_context>
@/Users/ardiansyahiqbal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ardiansyahiqbal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-task-management-integration/07-RESEARCH.md
@.planning/phases/05-calendar-integration/05-01-SUMMARY.md

# Pattern references
@apps/api/src/services/google-calendar.service.ts
@apps/api/src/services/bamboohr.service.ts
@apps/api/src/routes/oauth/google.ts
@apps/api/src/routes/oauth/bamboohr.ts
@packages/shared/src/types/integration.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Asana service with OAuth and task fetch</name>
  <files>apps/api/src/services/asana.service.ts</files>
  <action>
Create Asana service following google-calendar.service.ts pattern:

```typescript
import Asana from "asana";
import type { Task, TaskStatus, TaskTimeEntry } from "@klayim/shared";

interface AsanaTokenResponse {
  access_token: string;
  refresh_token: string;
  expires_in: number;
  token_type: string;
  data: { id: string; name: string; email: string };
}

interface AsanaTask {
  gid: string;
  name: string;
  notes?: string;
  completed: boolean;
  completed_at?: string;
  created_at: string;
  due_at?: string;
  actual_time_minutes?: number;
  assignee?: { gid: string; name: string; email: string };
}

class AsanaService {
  private readonly clientId = process.env.ASANA_CLIENT_ID!;
  private readonly clientSecret = process.env.ASANA_CLIENT_SECRET!;
  private readonly redirectUri = `${process.env.API_URL}/oauth/asana/callback`;

  /**
   * Generate OAuth authorization URL
   * State contains organizationId and redirectUrl as JSON
   */
  getAuthUrl(state: string): string {
    const params = new URLSearchParams({
      client_id: this.clientId,
      redirect_uri: this.redirectUri,
      response_type: "code",
      state,
    });
    return `https://app.asana.com/-/oauth_authorize?${params}`;
  }

  /**
   * Exchange authorization code for tokens
   */
  async exchangeCode(code: string): Promise<{
    accessToken: string;
    refreshToken: string;
    expiresIn: number;
    accountId: string;
    accountEmail: string;
    accountName: string;
  }> {
    const response = await fetch("https://app.asana.com/-/oauth_token", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({
        grant_type: "authorization_code",
        client_id: this.clientId,
        client_secret: this.clientSecret,
        redirect_uri: this.redirectUri,
        code,
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Asana token exchange failed: ${error}`);
    }

    const data: AsanaTokenResponse = await response.json();
    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresIn: data.expires_in,
      accountId: data.data.id,
      accountEmail: data.data.email,
      accountName: data.data.name,
    };
  }

  /**
   * Refresh expired access token
   */
  async refreshToken(refreshToken: string): Promise<{
    accessToken: string;
    refreshToken: string;
    expiresIn: number;
  }> {
    const response = await fetch("https://app.asana.com/-/oauth_token", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({
        grant_type: "refresh_token",
        client_id: this.clientId,
        client_secret: this.clientSecret,
        refresh_token: refreshToken,
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Asana token refresh failed: ${error}`);
    }

    const data = await response.json();
    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token || refreshToken,
      expiresIn: data.expires_in,
    };
  }

  /**
   * Get workspaces for the authenticated user
   */
  async getWorkspaces(accessToken: string): Promise<Array<{ gid: string; name: string }>> {
    const client = Asana.ApiClient.instance;
    client.authentications.oauth2.accessToken = accessToken;

    const workspacesApi = new Asana.WorkspacesApi();
    const result = await workspacesApi.getWorkspaces();
    return result.data.map((ws: { gid: string; name: string }) => ({
      gid: ws.gid,
      name: ws.name,
    }));
  }

  /**
   * Get projects in a workspace
   */
  async getProjects(
    accessToken: string,
    workspaceGid: string
  ): Promise<Array<{ gid: string; name: string }>> {
    const client = Asana.ApiClient.instance;
    client.authentications.oauth2.accessToken = accessToken;

    const projectsApi = new Asana.ProjectsApi();
    const result = await projectsApi.getProjectsForWorkspace(workspaceGid, {});
    return result.data.map((proj: { gid: string; name: string }) => ({
      gid: proj.gid,
      name: proj.name,
    }));
  }

  /**
   * Fetch tasks from a project with time tracking
   * Per research: actual_time_minutes is on task, detailed entries need separate call
   */
  async getTasks(accessToken: string, projectGid: string): Promise<AsanaTask[]> {
    const client = Asana.ApiClient.instance;
    client.authentications.oauth2.accessToken = accessToken;

    const tasksApi = new Asana.TasksApi();
    const opts = {
      opt_fields:
        "gid,name,notes,completed,completed_at,created_at,due_at,actual_time_minutes,assignee,assignee.email,assignee.name",
    };

    const result = await tasksApi.getTasksForProject(projectGid, opts);
    return result.data as AsanaTask[];
  }

  /**
   * Normalize Asana task to unified Task type
   */
  normalizeTask(
    asanaTask: AsanaTask,
    organizationId: string,
    integrationId: string,
    projectGid: string,
    projectName?: string
  ): Task {
    const status: TaskStatus = asanaTask.completed ? "done" : "todo";

    return {
      id: "", // Generated by repository
      organizationId,
      integrationId,
      provider: "asana",
      externalId: asanaTask.gid,
      title: asanaTask.name,
      description: asanaTask.notes,
      status,
      assigneeEmail: asanaTask.assignee?.email,
      assigneeExternalId: asanaTask.assignee?.gid,
      assigneeName: asanaTask.assignee?.name,
      createdAt: asanaTask.created_at,
      completedAt: asanaTask.completed_at,
      dueAt: asanaTask.due_at,
      timeSpentMinutes: asanaTask.actual_time_minutes,
      projectId: projectGid,
      projectName,
      syncedAt: new Date().toISOString(),
      updatedAt: asanaTask.created_at, // Asana doesn't return updated_at in task list
    };
  }
}

export const asanaService = new AsanaService();
```

Key decisions:
- Use asana SDK v3 for typed API calls
- Store workspace selection in accountId field
- Request actual_time_minutes field for time tracking
- Normalize to unified Task type
  </action>
  <verify>
```bash
cd apps/api && npx tsc --noEmit src/services/asana.service.ts
```
  </verify>
  <done>Asana service with OAuth flow, workspace/project fetch, and task normalization</done>
</task>

<task type="auto">
  <name>Task 2: Create ClickUp service with OAuth and task fetch</name>
  <files>apps/api/src/services/clickup.service.ts</files>
  <action>
Create ClickUp service (no official SDK - use direct fetch):

```typescript
import type { Task, TaskStatus } from "@klayim/shared";

interface ClickUpTokenResponse {
  access_token: string;
}

interface ClickUpUser {
  id: number;
  username: string;
  email: string;
}

interface ClickUpWorkspace {
  id: string;
  name: string;
}

interface ClickUpTask {
  id: string;
  name: string;
  description?: string;
  status: { status: string };
  date_created: string;
  date_closed?: string;
  date_done?: string;
  due_date?: string;
  time_spent?: number; // milliseconds
  time_estimate?: number; // milliseconds
  assignees: Array<{ id: number; email: string; username: string }>;
  list: { id: string; name: string };
  folder: { id: string; name: string };
}

class ClickUpService {
  private readonly clientId = process.env.CLICKUP_CLIENT_ID!;
  private readonly clientSecret = process.env.CLICKUP_CLIENT_SECRET!;
  private readonly redirectUri = `${process.env.API_URL}/oauth/clickup/callback`;
  private readonly baseUrl = "https://api.clickup.com/api/v2";

  /**
   * Generate OAuth authorization URL
   */
  getAuthUrl(state: string): string {
    const params = new URLSearchParams({
      client_id: this.clientId,
      redirect_uri: this.redirectUri,
      state,
    });
    return `https://app.clickup.com/api?${params}`;
  }

  /**
   * Exchange authorization code for token
   * ClickUp tokens don't expire - no refresh needed
   */
  async exchangeCode(code: string): Promise<{
    accessToken: string;
  }> {
    // ClickUp uses query params, not body
    const url =
      `${this.baseUrl}/oauth/token?` +
      `client_id=${this.clientId}` +
      `&client_secret=${this.clientSecret}` +
      `&code=${code}`;

    const response = await fetch(url, { method: "POST" });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`ClickUp token exchange failed: ${error}`);
    }

    const data: ClickUpTokenResponse = await response.json();
    return { accessToken: data.access_token };
  }

  /**
   * Get authenticated user info
   */
  async getUser(accessToken: string): Promise<ClickUpUser> {
    const response = await fetch(`${this.baseUrl}/user`, {
      headers: { Authorization: accessToken },
    });

    if (!response.ok) {
      throw new Error("Failed to get ClickUp user");
    }

    const data = await response.json();
    return data.user;
  }

  /**
   * Get workspaces (teams in ClickUp terminology)
   * Per research: ClickUp uses "team" for workspace in API
   */
  async getWorkspaces(accessToken: string): Promise<ClickUpWorkspace[]> {
    const response = await fetch(`${this.baseUrl}/team`, {
      headers: { Authorization: accessToken },
    });

    if (!response.ok) {
      throw new Error("Failed to get ClickUp workspaces");
    }

    const data = await response.json();
    return data.teams.map((team: { id: string; name: string }) => ({
      id: team.id,
      name: team.name,
    }));
  }

  /**
   * Get spaces in a workspace
   */
  async getSpaces(
    accessToken: string,
    workspaceId: string
  ): Promise<Array<{ id: string; name: string }>> {
    const response = await fetch(`${this.baseUrl}/team/${workspaceId}/space`, {
      headers: { Authorization: accessToken },
    });

    if (!response.ok) {
      throw new Error("Failed to get ClickUp spaces");
    }

    const data = await response.json();
    return data.spaces;
  }

  /**
   * Get lists in a space (tasks belong to lists)
   */
  async getLists(
    accessToken: string,
    spaceId: string
  ): Promise<Array<{ id: string; name: string }>> {
    const response = await fetch(`${this.baseUrl}/space/${spaceId}/list`, {
      headers: { Authorization: accessToken },
    });

    if (!response.ok) {
      throw new Error("Failed to get ClickUp lists");
    }

    const data = await response.json();
    return data.lists;
  }

  /**
   * Fetch tasks from a list with time tracking data
   */
  async getTasks(accessToken: string, listId: string): Promise<ClickUpTask[]> {
    const response = await fetch(
      `${this.baseUrl}/list/${listId}/task?include_closed=true`,
      {
        headers: {
          Authorization: accessToken,
          "Content-Type": "application/json",
        },
      }
    );

    if (!response.ok) {
      throw new Error("Failed to get ClickUp tasks");
    }

    const data = await response.json();
    return data.tasks;
  }

  /**
   * Normalize ClickUp task to unified Task type
   */
  normalizeTask(
    clickupTask: ClickUpTask,
    organizationId: string,
    integrationId: string,
    workspaceId: string
  ): Task {
    // Map ClickUp status to normalized status
    const statusLower = clickupTask.status.status.toLowerCase();
    let status: TaskStatus = "todo";
    if (statusLower === "complete" || statusLower === "closed" || clickupTask.date_closed) {
      status = "done";
    } else if (statusLower.includes("progress") || statusLower === "in progress") {
      status = "in_progress";
    }

    // ClickUp time is in milliseconds, convert to minutes
    const timeSpentMinutes = clickupTask.time_spent
      ? Math.round(clickupTask.time_spent / 60000)
      : undefined;
    const timeEstimateMinutes = clickupTask.time_estimate
      ? Math.round(clickupTask.time_estimate / 60000)
      : undefined;

    // Get primary assignee (first in list)
    const primaryAssignee = clickupTask.assignees[0];

    return {
      id: "", // Generated by repository
      organizationId,
      integrationId,
      provider: "clickup",
      externalId: clickupTask.id,
      title: clickupTask.name,
      description: clickupTask.description,
      status,
      assigneeEmail: primaryAssignee?.email,
      assigneeExternalId: primaryAssignee?.id?.toString(),
      assigneeName: primaryAssignee?.username,
      createdAt: new Date(parseInt(clickupTask.date_created)).toISOString(),
      completedAt: clickupTask.date_closed
        ? new Date(parseInt(clickupTask.date_closed)).toISOString()
        : undefined,
      dueAt: clickupTask.due_date
        ? new Date(parseInt(clickupTask.due_date)).toISOString()
        : undefined,
      timeSpentMinutes,
      timeEstimateMinutes,
      projectId: clickupTask.list.id,
      projectName: clickupTask.list.name,
      workspaceId,
      syncedAt: new Date().toISOString(),
      updatedAt: new Date(parseInt(clickupTask.date_created)).toISOString(),
    };
  }
}

export const clickupService = new ClickUpService();
```

Key decisions:
- No SDK - use typed fetch wrappers
- ClickUp tokens don't expire (no refresh needed, set far-future expiry)
- Convert millisecond timestamps to ISO strings
- Map ClickUp status strings to normalized TaskStatus
  </action>
  <verify>
```bash
cd apps/api && npx tsc --noEmit src/services/clickup.service.ts
```
  </verify>
  <done>ClickUp service with OAuth flow, workspace/list fetch, and task normalization</done>
</task>

<task type="auto">
  <name>Task 3: Create Linear service with OAuth and issue fetch</name>
  <files>apps/api/src/services/linear.service.ts</files>
  <action>
Create Linear service using @linear/sdk:

```typescript
import { LinearClient } from "@linear/sdk";
import type { Task, TaskStatus } from "@klayim/shared";

interface LinearTokenResponse {
  access_token: string;
  refresh_token: string;
  expires_in: number;
  token_type: string;
  scope: string;
}

class LinearService {
  private readonly clientId = process.env.LINEAR_CLIENT_ID!;
  private readonly clientSecret = process.env.LINEAR_CLIENT_SECRET!;
  private readonly redirectUri = `${process.env.API_URL}/oauth/linear/callback`;

  /**
   * Generate OAuth authorization URL
   * Linear supports PKCE but we use standard OAuth for simplicity
   */
  getAuthUrl(state: string): string {
    const params = new URLSearchParams({
      client_id: this.clientId,
      redirect_uri: this.redirectUri,
      response_type: "code",
      scope: "read", // Read-only access to issues
      state,
    });
    return `https://linear.app/oauth/authorize?${params}`;
  }

  /**
   * Exchange authorization code for tokens
   */
  async exchangeCode(code: string): Promise<{
    accessToken: string;
    refreshToken: string;
    expiresIn: number;
    accountId: string;
    accountEmail: string;
    accountName: string;
  }> {
    const response = await fetch("https://api.linear.app/oauth/token", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({
        grant_type: "authorization_code",
        client_id: this.clientId,
        client_secret: this.clientSecret,
        redirect_uri: this.redirectUri,
        code,
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Linear token exchange failed: ${error}`);
    }

    const data: LinearTokenResponse = await response.json();

    // Get user info via SDK
    const client = new LinearClient({ accessToken: data.access_token });
    const viewer = await client.viewer;

    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresIn: data.expires_in,
      accountId: viewer.id,
      accountEmail: viewer.email || "",
      accountName: viewer.name || "",
    };
  }

  /**
   * Refresh expired access token
   * Per research: Linear is migrating to mandatory refresh tokens (April 2026)
   */
  async refreshToken(refreshToken: string): Promise<{
    accessToken: string;
    refreshToken: string;
    expiresIn: number;
  }> {
    const response = await fetch("https://api.linear.app/oauth/token", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({
        grant_type: "refresh_token",
        client_id: this.clientId,
        client_secret: this.clientSecret,
        refresh_token: refreshToken,
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Linear token refresh failed: ${error}`);
    }

    const data = await response.json();
    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token || refreshToken,
      expiresIn: data.expires_in,
    };
  }

  /**
   * Get teams (workspaces) for the authenticated user
   */
  async getTeams(accessToken: string): Promise<Array<{ id: string; name: string; key: string }>> {
    const client = new LinearClient({ accessToken });
    const teams = await client.teams();

    return teams.nodes.map((team) => ({
      id: team.id,
      name: team.name,
      key: team.key,
    }));
  }

  /**
   * Get projects in a team
   */
  async getProjects(
    accessToken: string,
    teamId: string
  ): Promise<Array<{ id: string; name: string }>> {
    const client = new LinearClient({ accessToken });
    const team = await client.team(teamId);
    const projects = await team.projects();

    return projects.nodes.map((project) => ({
      id: project.id,
      name: project.name,
    }));
  }

  /**
   * Fetch issues from a team
   * Per research: Linear has estimate (points) not time tracking
   */
  async getIssues(
    accessToken: string,
    teamId: string
  ): Promise<
    Array<{
      id: string;
      identifier: string;
      title: string;
      description?: string;
      state: { name: string; type: string };
      assignee?: { id: string; email: string; name: string };
      createdAt: Date;
      completedAt?: Date;
      dueDate?: string;
      estimate?: number;
      project?: { id: string; name: string };
      updatedAt: Date;
    }>
  > {
    const client = new LinearClient({ accessToken });
    const issues = await client.issues({
      filter: { team: { id: { eq: teamId } } },
      includeArchived: false,
    });

    const results = [];
    for (const issue of issues.nodes) {
      const state = await issue.state;
      const assignee = await issue.assignee;
      const project = await issue.project;

      results.push({
        id: issue.id,
        identifier: issue.identifier,
        title: issue.title,
        description: issue.description,
        state: state ? { name: state.name, type: state.type } : { name: "Unknown", type: "triage" },
        assignee: assignee
          ? { id: assignee.id, email: assignee.email || "", name: assignee.name || "" }
          : undefined,
        createdAt: issue.createdAt,
        completedAt: issue.completedAt || undefined,
        dueDate: issue.dueDate || undefined,
        estimate: issue.estimate || undefined,
        project: project ? { id: project.id, name: project.name } : undefined,
        updatedAt: issue.updatedAt,
      });
    }

    return results;
  }

  /**
   * Normalize Linear issue to unified Task type
   * Per research: estimate is story points, NOT time tracking
   */
  normalizeTask(
    linearIssue: {
      id: string;
      identifier: string;
      title: string;
      description?: string;
      state: { name: string; type: string };
      assignee?: { id: string; email: string; name: string };
      createdAt: Date;
      completedAt?: Date;
      dueDate?: string;
      estimate?: number;
      project?: { id: string; name: string };
      updatedAt: Date;
    },
    organizationId: string,
    integrationId: string,
    teamId: string
  ): Task {
    // Map Linear state types to normalized status
    let status: TaskStatus = "todo";
    const stateType = linearIssue.state.type.toLowerCase();
    if (stateType === "completed" || linearIssue.completedAt) {
      status = "done";
    } else if (stateType === "started") {
      status = "in_progress";
    } else if (stateType === "canceled" || stateType === "cancelled") {
      status = "cancelled";
    }

    return {
      id: "", // Generated by repository
      organizationId,
      integrationId,
      provider: "linear",
      externalId: linearIssue.id,
      title: `${linearIssue.identifier}: ${linearIssue.title}`,
      description: linearIssue.description,
      status,
      assigneeEmail: linearIssue.assignee?.email,
      assigneeExternalId: linearIssue.assignee?.id,
      assigneeName: linearIssue.assignee?.name,
      createdAt: linearIssue.createdAt.toISOString(),
      completedAt: linearIssue.completedAt?.toISOString(),
      dueAt: linearIssue.dueDate,
      // Linear uses estimates (story points), not time tracking
      estimatePoints: linearIssue.estimate,
      // No time tracking for Linear
      timeSpentMinutes: undefined,
      timeEstimateMinutes: undefined,
      projectId: linearIssue.project?.id,
      projectName: linearIssue.project?.name,
      workspaceId: teamId,
      syncedAt: new Date().toISOString(),
      updatedAt: linearIssue.updatedAt.toISOString(),
    };
  }
}

export const linearService = new LinearService();
```

Key decisions:
- Use @linear/sdk for typed GraphQL queries
- Map state.type to normalized TaskStatus
- Store estimate in estimatePoints (not time tracking)
- Include identifier in title for context (e.g., "ENG-123: Bug fix")
  </action>
  <verify>
```bash
cd apps/api && npx tsc --noEmit src/services/linear.service.ts
```
  </verify>
  <done>Linear service with OAuth flow, team/project fetch, and issue normalization</done>
</task>

<task type="auto">
  <name>Task 4: Create OAuth routes for all three providers</name>
  <files>apps/api/src/routes/oauth/asana.ts, apps/api/src/routes/oauth/clickup.ts, apps/api/src/routes/oauth/linear.ts, apps/api/src/routes/oauth/index.ts</files>
  <action>
Create OAuth routes following the bamboohr.ts pattern:

**apps/api/src/routes/oauth/asana.ts:**
```typescript
import { Hono } from "hono";
import { asanaService } from "../../services/asana.service.js";
import { integrationService } from "../../services/integration.service.js";
import { taskSyncService } from "../../services/task-sync.service.js";
import { authMiddleware } from "../../middleware/auth.js";

export const asanaOAuth = new Hono();

/**
 * GET /oauth/asana/authorize
 * Start Asana OAuth flow - requires authenticated user
 */
asanaOAuth.get("/authorize", authMiddleware, async (c) => {
  const organizationId = c.get("organizationId");
  const redirectUrl = c.req.query("redirectUrl") || "/onboarding/connect-task";

  if (!organizationId) {
    return c.json({ error: "Organization required" }, 400);
  }

  const state = JSON.stringify({ organizationId, redirectUrl });
  const url = asanaService.getAuthUrl(state);

  return c.json({ url });
});

/**
 * GET /oauth/asana/callback
 * Handle Asana OAuth callback - public endpoint
 */
asanaOAuth.get("/callback", async (c) => {
  const code = c.req.query("code");
  const stateParam = c.req.query("state");
  const error = c.req.query("error");

  if (error) {
    const redirectUrl = "/onboarding/connect-task";
    return c.redirect(`${redirectUrl}?error=${error}&provider=asana`);
  }

  if (!code || !stateParam) {
    return c.redirect("/onboarding/connect-task?error=missing_params&provider=asana");
  }

  let state: { organizationId: string; redirectUrl: string };
  try {
    state = JSON.parse(stateParam);
  } catch {
    return c.redirect("/onboarding/connect-task?error=invalid_state&provider=asana");
  }

  try {
    // Exchange code for tokens
    const tokens = await asanaService.exchangeCode(code);

    // Create or update integration
    const expiresAt = new Date(Date.now() + tokens.expiresIn * 1000).toISOString();

    await integrationService.upsertIntegration({
      organizationId: state.organizationId,
      provider: "asana",
      accountId: tokens.accountId,
      accountEmail: tokens.accountEmail,
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      expiresAt,
      scopes: ["default"],
    });

    // Trigger initial sync (async, don't await)
    taskSyncService.triggerInitialSync(state.organizationId, "asana").catch(console.error);

    return c.redirect(`${state.redirectUrl}?success=true&provider=asana`);
  } catch (err) {
    console.error("Asana OAuth callback error:", err);
    const message = err instanceof Error ? err.message : "Unknown error";
    return c.redirect(
      `${state.redirectUrl}?error=exchange_failed&provider=asana&message=${encodeURIComponent(message)}`
    );
  }
});
```

**apps/api/src/routes/oauth/clickup.ts:**
```typescript
import { Hono } from "hono";
import { clickupService } from "../../services/clickup.service.js";
import { integrationService } from "../../services/integration.service.js";
import { taskSyncService } from "../../services/task-sync.service.js";
import { authMiddleware } from "../../middleware/auth.js";

export const clickupOAuth = new Hono();

/**
 * GET /oauth/clickup/authorize
 * Start ClickUp OAuth flow
 */
clickupOAuth.get("/authorize", authMiddleware, async (c) => {
  const organizationId = c.get("organizationId");
  const redirectUrl = c.req.query("redirectUrl") || "/onboarding/connect-task";

  if (!organizationId) {
    return c.json({ error: "Organization required" }, 400);
  }

  const state = JSON.stringify({ organizationId, redirectUrl });
  const url = clickupService.getAuthUrl(state);

  return c.json({ url });
});

/**
 * GET /oauth/clickup/callback
 * Handle ClickUp OAuth callback
 */
clickupOAuth.get("/callback", async (c) => {
  const code = c.req.query("code");
  const stateParam = c.req.query("state");
  const error = c.req.query("error");

  if (error) {
    const redirectUrl = "/onboarding/connect-task";
    return c.redirect(`${redirectUrl}?error=${error}&provider=clickup`);
  }

  if (!code || !stateParam) {
    return c.redirect("/onboarding/connect-task?error=missing_params&provider=clickup");
  }

  let state: { organizationId: string; redirectUrl: string };
  try {
    state = JSON.parse(stateParam);
  } catch {
    return c.redirect("/onboarding/connect-task?error=invalid_state&provider=clickup");
  }

  try {
    // Exchange code for token
    const { accessToken } = await clickupService.exchangeCode(code);

    // Get user info for account details
    const user = await clickupService.getUser(accessToken);

    // Get first workspace as default (user can change later)
    const workspaces = await clickupService.getWorkspaces(accessToken);
    const defaultWorkspace = workspaces[0];

    // ClickUp tokens don't expire - set far future expiry
    const expiresAt = new Date(Date.now() + 10 * 365 * 24 * 60 * 60 * 1000).toISOString();

    await integrationService.upsertIntegration({
      organizationId: state.organizationId,
      provider: "clickup",
      accountId: defaultWorkspace?.id || user.id.toString(),
      accountEmail: user.email,
      accessToken,
      refreshToken: "", // ClickUp doesn't use refresh tokens
      expiresAt,
      scopes: ["default"],
    });

    // Trigger initial sync (async, don't await)
    taskSyncService.triggerInitialSync(state.organizationId, "clickup").catch(console.error);

    return c.redirect(`${state.redirectUrl}?success=true&provider=clickup`);
  } catch (err) {
    console.error("ClickUp OAuth callback error:", err);
    const message = err instanceof Error ? err.message : "Unknown error";
    return c.redirect(
      `${state.redirectUrl}?error=exchange_failed&provider=clickup&message=${encodeURIComponent(message)}`
    );
  }
});
```

**apps/api/src/routes/oauth/linear.ts:**
```typescript
import { Hono } from "hono";
import { linearService } from "../../services/linear.service.js";
import { integrationService } from "../../services/integration.service.js";
import { taskSyncService } from "../../services/task-sync.service.js";
import { authMiddleware } from "../../middleware/auth.js";

export const linearOAuth = new Hono();

/**
 * GET /oauth/linear/authorize
 * Start Linear OAuth flow
 */
linearOAuth.get("/authorize", authMiddleware, async (c) => {
  const organizationId = c.get("organizationId");
  const redirectUrl = c.req.query("redirectUrl") || "/onboarding/connect-task";

  if (!organizationId) {
    return c.json({ error: "Organization required" }, 400);
  }

  const state = JSON.stringify({ organizationId, redirectUrl });
  const url = linearService.getAuthUrl(state);

  return c.json({ url });
});

/**
 * GET /oauth/linear/callback
 * Handle Linear OAuth callback
 */
linearOAuth.get("/callback", async (c) => {
  const code = c.req.query("code");
  const stateParam = c.req.query("state");
  const error = c.req.query("error");

  if (error) {
    const redirectUrl = "/onboarding/connect-task";
    return c.redirect(`${redirectUrl}?error=${error}&provider=linear`);
  }

  if (!code || !stateParam) {
    return c.redirect("/onboarding/connect-task?error=missing_params&provider=linear");
  }

  let state: { organizationId: string; redirectUrl: string };
  try {
    state = JSON.parse(stateParam);
  } catch {
    return c.redirect("/onboarding/connect-task?error=invalid_state&provider=linear");
  }

  try {
    // Exchange code for tokens
    const tokens = await linearService.exchangeCode(code);

    // Calculate expiry
    const expiresAt = new Date(Date.now() + tokens.expiresIn * 1000).toISOString();

    await integrationService.upsertIntegration({
      organizationId: state.organizationId,
      provider: "linear",
      accountId: tokens.accountId,
      accountEmail: tokens.accountEmail,
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      expiresAt,
      scopes: ["read"],
    });

    // Trigger initial sync (async, don't await)
    taskSyncService.triggerInitialSync(state.organizationId, "linear").catch(console.error);

    return c.redirect(`${state.redirectUrl}?success=true&provider=linear`);
  } catch (err) {
    console.error("Linear OAuth callback error:", err);
    const message = err instanceof Error ? err.message : "Unknown error";
    return c.redirect(
      `${state.redirectUrl}?error=exchange_failed&provider=linear&message=${encodeURIComponent(message)}`
    );
  }
});
```

**Update apps/api/src/routes/oauth/index.ts:**
Add the three new routes:
```typescript
import { Hono } from "hono";
import { googleOAuth } from "./google.js";
import { microsoftOAuth } from "./microsoft.js";
import { bambooHROAuth } from "./bamboohr.js";
import { finchOAuth } from "./finch.js";
import { asanaOAuth } from "./asana.js";
import { clickupOAuth } from "./clickup.js";
import { linearOAuth } from "./linear.js";

/**
 * OAuth Routes
 *
 * Mounts provider-specific OAuth routes:
 * - /google - Google Calendar OAuth
 * - /microsoft - Microsoft Calendar OAuth
 * - /bamboohr - BambooHR HRIS OAuth
 * - /finch - Finch unified HRIS OAuth (Rippling, Gusto, etc.)
 * - /asana - Asana task management OAuth
 * - /clickup - ClickUp task management OAuth
 * - /linear - Linear task management OAuth
 */
export const oauthRoutes = new Hono();

// Mount Google OAuth routes at /google
oauthRoutes.route("/google", googleOAuth);

// Mount Microsoft OAuth routes at /microsoft
oauthRoutes.route("/microsoft", microsoftOAuth);

// Mount BambooHR OAuth routes at /bamboohr
oauthRoutes.route("/bamboohr", bambooHROAuth);

// Mount Finch OAuth routes at /finch
oauthRoutes.route("/finch", finchOAuth);

// Mount Asana OAuth routes at /asana
oauthRoutes.route("/asana", asanaOAuth);

// Mount ClickUp OAuth routes at /clickup
oauthRoutes.route("/clickup", clickupOAuth);

// Mount Linear OAuth routes at /linear
oauthRoutes.route("/linear", linearOAuth);
```
  </action>
  <verify>
```bash
cd apps/api && npx tsc --noEmit src/routes/oauth/asana.ts src/routes/oauth/clickup.ts src/routes/oauth/linear.ts
```
  </verify>
  <done>OAuth routes for Asana, ClickUp, Linear mounted at /oauth/{provider}</done>
</task>

<task type="auto">
  <name>Task 5: Update token refresh service and exports</name>
  <files>apps/api/src/services/token-refresh.service.ts, apps/api/src/services/index.ts</files>
  <action>
Add token refresh implementations for task providers:

**Update apps/api/src/services/token-refresh.service.ts:**
Add cases for asana, clickup, linear in the refreshIntegrationToken method:

```typescript
// Add imports at top
import { asanaService } from "./asana.service.js";
import { linearService } from "./linear.service.js";

// In refreshIntegrationToken method, add cases in the switch statement:
case "asana": {
  const result = await asanaService.refreshToken(credentials.refreshToken);
  return {
    accessToken: result.accessToken,
    refreshToken: result.refreshToken,
    expiresIn: result.expiresIn,
  };
}

case "clickup": {
  // ClickUp tokens don't expire - no refresh needed
  throw new Error("ClickUp tokens do not expire");
}

case "linear": {
  const result = await linearService.refreshToken(credentials.refreshToken);
  return {
    accessToken: result.accessToken,
    refreshToken: result.refreshToken,
    expiresIn: result.expiresIn,
  };
}
```

**Update apps/api/src/services/index.ts:**
Add exports for new services:
```typescript
export * from "./asana.service.js";
export * from "./clickup.service.js";
export * from "./linear.service.js";
```
  </action>
  <verify>
```bash
cd apps/api && npx tsc --noEmit src/services/token-refresh.service.ts
```
  </verify>
  <done>Token refresh service handles Asana/Linear refresh, ClickUp skip (no expiry)</done>
</task>

</tasks>

<verification>
- [ ] All services compile: `cd apps/api && npx tsc --noEmit`
- [ ] Services exported: `grep -l "asana\|clickup\|linear" apps/api/src/services/index.ts`
- [ ] OAuth routes mounted: `grep -c "oauthRoutes.route" apps/api/src/routes/oauth/index.ts` (should be 7)
- [ ] Token refresh cases added: `grep -c "case \"asana\"\|case \"clickup\"\|case \"linear\"" apps/api/src/services/token-refresh.service.ts` (should be 3)
</verification>

<success_criteria>
1. GET /oauth/asana/authorize returns authorization URL
2. GET /oauth/clickup/authorize returns authorization URL
3. GET /oauth/linear/authorize returns authorization URL
4. OAuth callbacks create integrations with encrypted tokens
5. Token refresh works for Asana and Linear (ClickUp doesn't expire)
6. All services properly normalize tasks to unified Task type
</success_criteria>

<output>
After completion, create `.planning/phases/07-task-management-integration/07-02-SUMMARY.md`
</output>
