---
phase: 07-task-management-integration
plan: 03
type: execute
wave: 3
depends_on: [07-02]
files_modified:
  - apps/api/src/services/task-sync.service.ts
  - apps/api/src/repositories/task.repository.ts
  - apps/api/src/repositories/index.ts
  - apps/web/src/lib/api/tasks.ts
  - apps/web/src/components/pages/onboarding/connect-task/index.tsx
autonomous: true
requirements: [TASK-04, TASK-05, TASK-06]

must_haves:
  truths:
    - "System imports tasks from connected providers"
    - "Tasks are stored with normalized fields (status, dates, assignees)"
    - "Time tracking data is captured for Asana and ClickUp"
    - "Linear estimates are stored as points (not time)"
    - "User sees InfoAccordion explaining what data will be imported"
    - "Connect buttons trigger OAuth flows"
  artifacts:
    - path: "apps/api/src/services/task-sync.service.ts"
      provides: "Task sync orchestration service"
      exports: ["taskSyncService"]
    - path: "apps/api/src/repositories/task.repository.ts"
      provides: "Task Firestore repository"
      exports: ["taskRepository"]
    - path: "apps/web/src/lib/api/tasks.ts"
      provides: "Task API client functions"
      exports: ["getAsanaAuthUrl", "getClickUpAuthUrl", "getLinearAuthUrl"]
    - path: "apps/web/src/components/pages/onboarding/connect-task/index.tsx"
      provides: "Connect task page with OAuth handlers"
      contains: "handleConnectAsana"
  key_links:
    - from: "apps/api/src/services/task-sync.service.ts"
      to: "apps/api/src/repositories/task.repository.ts"
      via: "repository import"
      pattern: "taskRepository"
    - from: "apps/web/src/components/pages/onboarding/connect-task/index.tsx"
      to: "apps/web/src/lib/api/tasks.ts"
      via: "API client import"
      pattern: "getAsanaAuthUrl"
---

<objective>
Create task sync service, task repository, and wire up frontend connect page

Purpose: Complete the task management integration by enabling actual data sync and user connection flow
Output: TaskSyncService for provider sync, TaskRepository for storage, updated frontend connect-task page
</objective>

<execution_context>
@/Users/ardiansyahiqbal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ardiansyahiqbal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-task-management-integration/07-RESEARCH.md
@.planning/phases/06-hris-integration/06-01-SUMMARY.md

# Pattern references
@apps/api/src/services/hris-sync.service.ts
@apps/api/src/services/calendar-sync.service.ts
@apps/api/src/repositories/employee.repository.ts
@apps/web/src/components/pages/onboarding/connect-hris/index.tsx
@apps/web/src/lib/api/hris.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create task repository for Firestore storage</name>
  <files>apps/api/src/repositories/task.repository.ts, apps/api/src/repositories/index.ts</files>
  <action>
Create task repository following employee.repository.ts pattern:

**apps/api/src/repositories/task.repository.ts:**
```typescript
import { db } from "../lib/firebase.js";
import type { Task, TaskSyncState } from "@klayim/shared";
import {
  collection,
  doc,
  getDoc,
  getDocs,
  setDoc,
  deleteDoc,
  query,
  where,
  writeBatch,
  Timestamp,
} from "firebase/firestore";

const TASKS_COLLECTION = "tasks";
const TASK_SYNC_STATES_COLLECTION = "taskSyncStates";

class TaskRepository {
  /**
   * Upsert a task by externalId (idempotent)
   */
  async upsertTask(task: Omit<Task, "id">): Promise<Task> {
    // Find existing by provider + externalId
    const existingQuery = query(
      collection(db, TASKS_COLLECTION),
      where("organizationId", "==", task.organizationId),
      where("provider", "==", task.provider),
      where("externalId", "==", task.externalId)
    );

    const existing = await getDocs(existingQuery);

    let taskId: string;
    if (!existing.empty) {
      taskId = existing.docs[0].id;
    } else {
      taskId = doc(collection(db, TASKS_COLLECTION)).id;
    }

    const taskDoc: Task = {
      ...task,
      id: taskId,
    };

    await setDoc(doc(db, TASKS_COLLECTION, taskId), taskDoc);
    return taskDoc;
  }

  /**
   * Bulk upsert tasks (more efficient for initial sync)
   */
  async bulkUpsertTasks(tasks: Omit<Task, "id">[]): Promise<number> {
    if (tasks.length === 0) return 0;

    const batch = writeBatch(db);
    let count = 0;

    for (const task of tasks) {
      // Find existing
      const existingQuery = query(
        collection(db, TASKS_COLLECTION),
        where("organizationId", "==", task.organizationId),
        where("provider", "==", task.provider),
        where("externalId", "==", task.externalId)
      );

      const existing = await getDocs(existingQuery);

      let taskId: string;
      if (!existing.empty) {
        taskId = existing.docs[0].id;
      } else {
        taskId = doc(collection(db, TASKS_COLLECTION)).id;
      }

      const taskDoc: Task = { ...task, id: taskId };
      batch.set(doc(db, TASKS_COLLECTION, taskId), taskDoc);
      count++;

      // Firestore batch limit is 500
      if (count % 400 === 0) {
        await batch.commit();
      }
    }

    await batch.commit();
    return count;
  }

  /**
   * Get all tasks for an organization
   */
  async getTasksByOrganization(organizationId: string): Promise<Task[]> {
    const q = query(
      collection(db, TASKS_COLLECTION),
      where("organizationId", "==", organizationId)
    );
    const snapshot = await getDocs(q);
    return snapshot.docs.map((doc) => doc.data() as Task);
  }

  /**
   * Get tasks by integration
   */
  async getTasksByIntegration(integrationId: string): Promise<Task[]> {
    const q = query(
      collection(db, TASKS_COLLECTION),
      where("integrationId", "==", integrationId)
    );
    const snapshot = await getDocs(q);
    return snapshot.docs.map((doc) => doc.data() as Task);
  }

  /**
   * Delete tasks for an integration (on disconnect)
   */
  async deleteTasksByIntegration(integrationId: string): Promise<number> {
    const tasks = await this.getTasksByIntegration(integrationId);
    const batch = writeBatch(db);

    for (const task of tasks) {
      batch.delete(doc(db, TASKS_COLLECTION, task.id));
    }

    await batch.commit();
    return tasks.length;
  }

  /**
   * Get sync state for an integration
   */
  async getSyncState(integrationId: string): Promise<TaskSyncState | null> {
    const docRef = doc(db, TASK_SYNC_STATES_COLLECTION, integrationId);
    const snapshot = await getDoc(docRef);

    if (!snapshot.exists()) return null;
    return snapshot.data() as TaskSyncState;
  }

  /**
   * Update sync state
   */
  async updateSyncState(state: TaskSyncState): Promise<void> {
    await setDoc(doc(db, TASK_SYNC_STATES_COLLECTION, state.integrationId), state);
  }
}

export const taskRepository = new TaskRepository();
```

**Update apps/api/src/repositories/index.ts:**
Add export:
```typescript
export * from "./task.repository.js";
```
  </action>
  <verify>
```bash
cd apps/api && npx tsc --noEmit src/repositories/task.repository.ts
```
  </verify>
  <done>Task repository with upsert, bulk operations, and sync state tracking</done>
</task>

<task type="auto">
  <name>Task 2: Create task sync service for all providers</name>
  <files>apps/api/src/services/task-sync.service.ts, apps/api/src/services/index.ts</files>
  <action>
Create unified task sync service following hris-sync.service.ts pattern:

**apps/api/src/services/task-sync.service.ts:**
```typescript
import { taskRepository } from "../repositories/task.repository.js";
import { integrationRepository } from "../repositories/integration.repository.js";
import { decrypt } from "../lib/encryption.js";
import { asanaService } from "./asana.service.js";
import { clickupService } from "./clickup.service.js";
import { linearService } from "./linear.service.js";
import type { Task, TaskSyncState, TaskProvider } from "@klayim/shared";

interface SyncResult {
  success: boolean;
  tasksImported: number;
  error?: string;
}

class TaskSyncService {
  /**
   * Trigger initial sync after OAuth connection (async, non-blocking)
   */
  async triggerInitialSync(organizationId: string, provider: TaskProvider): Promise<void> {
    console.log(`Triggering initial task sync for ${provider} in org ${organizationId}`);

    try {
      // Get integration
      const integrations = await integrationRepository.getByOrganization(organizationId);
      const integration = integrations.find((i) => i.provider === provider && i.status === "connected");

      if (!integration) {
        console.error(`No connected ${provider} integration found for org ${organizationId}`);
        return;
      }

      // Update sync state to in_progress
      await taskRepository.updateSyncState({
        id: integration.id,
        integrationId: integration.id,
        organizationId,
        provider,
        lastSyncAt: new Date().toISOString(),
        lastSyncStatus: "in_progress",
        taskCount: 0,
      });

      // Run sync
      const result = await this.syncFromProvider(integration.id);

      // Update sync state with result
      const currentState = await taskRepository.getSyncState(integration.id);
      await taskRepository.updateSyncState({
        ...currentState!,
        lastSyncAt: new Date().toISOString(),
        lastSyncStatus: result.success ? "success" : "error",
        lastError: result.error,
        taskCount: result.tasksImported,
      });

      console.log(`Task sync completed: ${result.tasksImported} tasks imported`);
    } catch (error) {
      console.error(`Task sync failed:`, error);
    }
  }

  /**
   * Sync tasks from a specific integration
   */
  async syncFromProvider(integrationId: string): Promise<SyncResult> {
    const integration = await integrationRepository.getById(integrationId);
    if (!integration) {
      return { success: false, tasksImported: 0, error: "Integration not found" };
    }

    // Decrypt credentials
    const credentials = await decrypt(integration.credentials);
    const accessToken = credentials.accessToken;

    switch (integration.provider) {
      case "asana":
        return this.syncFromAsana(integration.id, integration.organizationId, accessToken);
      case "clickup":
        return this.syncFromClickUp(integration.id, integration.organizationId, accessToken, integration.accountId);
      case "linear":
        return this.syncFromLinear(integration.id, integration.organizationId, accessToken);
      default:
        return { success: false, tasksImported: 0, error: `Unknown provider: ${integration.provider}` };
    }
  }

  /**
   * Sync tasks from Asana
   * Fetches all workspaces, all projects, all tasks
   */
  private async syncFromAsana(
    integrationId: string,
    organizationId: string,
    accessToken: string
  ): Promise<SyncResult> {
    try {
      const tasks: Omit<Task, "id">[] = [];

      // Get all workspaces
      const workspaces = await asanaService.getWorkspaces(accessToken);

      for (const workspace of workspaces) {
        // Get all projects in workspace
        const projects = await asanaService.getProjects(accessToken, workspace.gid);

        for (const project of projects) {
          // Get all tasks in project
          const asanaTasks = await asanaService.getTasks(accessToken, project.gid);

          for (const asanaTask of asanaTasks) {
            const normalizedTask = asanaService.normalizeTask(
              asanaTask,
              organizationId,
              integrationId,
              project.gid,
              project.name
            );
            tasks.push(normalizedTask);
          }
        }
      }

      // Bulk upsert
      const count = await taskRepository.bulkUpsertTasks(tasks);
      return { success: true, tasksImported: count };
    } catch (error) {
      return {
        success: false,
        tasksImported: 0,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  /**
   * Sync tasks from ClickUp
   * Uses workspace ID from accountId
   */
  private async syncFromClickUp(
    integrationId: string,
    organizationId: string,
    accessToken: string,
    workspaceId: string
  ): Promise<SyncResult> {
    try {
      const tasks: Omit<Task, "id">[] = [];

      // Get spaces in workspace
      const spaces = await clickupService.getSpaces(accessToken, workspaceId);

      for (const space of spaces) {
        // Get lists in space
        const lists = await clickupService.getLists(accessToken, space.id);

        for (const list of lists) {
          // Get tasks in list
          const clickupTasks = await clickupService.getTasks(accessToken, list.id);

          for (const clickupTask of clickupTasks) {
            const normalizedTask = clickupService.normalizeTask(
              clickupTask,
              organizationId,
              integrationId,
              workspaceId
            );
            tasks.push(normalizedTask);
          }
        }
      }

      // Bulk upsert
      const count = await taskRepository.bulkUpsertTasks(tasks);
      return { success: true, tasksImported: count };
    } catch (error) {
      return {
        success: false,
        tasksImported: 0,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  /**
   * Sync issues from Linear
   * Fetches all teams and their issues
   */
  private async syncFromLinear(
    integrationId: string,
    organizationId: string,
    accessToken: string
  ): Promise<SyncResult> {
    try {
      const tasks: Omit<Task, "id">[] = [];

      // Get all teams
      const teams = await linearService.getTeams(accessToken);

      for (const team of teams) {
        // Get issues in team
        const issues = await linearService.getIssues(accessToken, team.id);

        for (const issue of issues) {
          const normalizedTask = linearService.normalizeTask(
            issue,
            organizationId,
            integrationId,
            team.id
          );
          tasks.push(normalizedTask);
        }
      }

      // Bulk upsert
      const count = await taskRepository.bulkUpsertTasks(tasks);
      return { success: true, tasksImported: count };
    } catch (error) {
      return {
        success: false,
        tasksImported: 0,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  /**
   * Get sync status for an integration
   */
  async getSyncStatus(integrationId: string): Promise<TaskSyncState | null> {
    return taskRepository.getSyncState(integrationId);
  }
}

export const taskSyncService = new TaskSyncService();
```

**Update apps/api/src/services/index.ts:**
Add export:
```typescript
export * from "./task-sync.service.js";
```
  </action>
  <verify>
```bash
cd apps/api && npx tsc --noEmit src/services/task-sync.service.ts
```
  </verify>
  <done>TaskSyncService with provider-specific sync methods and bulk task import</done>
</task>

<task type="auto">
  <name>Task 3: Create frontend API client for task OAuth</name>
  <files>apps/web/src/lib/api/tasks.ts</files>
  <action>
Create API client functions following hris.ts pattern:

**apps/web/src/lib/api/tasks.ts:**
```typescript
import { apiClient } from "./client";

/**
 * Get Asana OAuth authorization URL
 */
export async function getAsanaAuthUrl(
  organizationId: string,
  redirectUrl: string
): Promise<{ url: string }> {
  const response = await apiClient.get<{ url: string }>(
    `/oauth/asana/authorize?redirectUrl=${encodeURIComponent(redirectUrl)}`,
    {
      headers: {
        "x-organization-id": organizationId,
      },
    }
  );
  return response;
}

/**
 * Get ClickUp OAuth authorization URL
 */
export async function getClickUpAuthUrl(
  organizationId: string,
  redirectUrl: string
): Promise<{ url: string }> {
  const response = await apiClient.get<{ url: string }>(
    `/oauth/clickup/authorize?redirectUrl=${encodeURIComponent(redirectUrl)}`,
    {
      headers: {
        "x-organization-id": organizationId,
      },
    }
  );
  return response;
}

/**
 * Get Linear OAuth authorization URL
 */
export async function getLinearAuthUrl(
  organizationId: string,
  redirectUrl: string
): Promise<{ url: string }> {
  const response = await apiClient.get<{ url: string }>(
    `/oauth/linear/authorize?redirectUrl=${encodeURIComponent(redirectUrl)}`,
    {
      headers: {
        "x-organization-id": organizationId,
      },
    }
  );
  return response;
}

/**
 * Get task sync status for an organization
 */
export async function getTaskSyncStatus(
  organizationId: string,
  provider: "asana" | "clickup" | "linear"
): Promise<{
  status: "connected" | "disconnected" | "syncing" | "error";
  taskCount?: number;
  lastSyncAt?: string;
  error?: string;
}> {
  const response = await apiClient.get<{
    status: "connected" | "disconnected" | "syncing" | "error";
    taskCount?: number;
    lastSyncAt?: string;
    error?: string;
  }>(`/integrations/task/${provider}/status`, {
    headers: {
      "x-organization-id": organizationId,
    },
  });
  return response;
}
```
  </action>
  <verify>
```bash
cd apps/web && npx tsc --noEmit src/lib/api/tasks.ts
```
  </verify>
  <done>Task API client with OAuth URL and status functions</done>
</task>

<task type="auto">
  <name>Task 4: Wire up connect-task page with OAuth handlers</name>
  <files>apps/web/src/components/pages/onboarding/connect-task/index.tsx</files>
  <action>
Update connect-task page following connect-hris pattern:

Replace the placeholder "coming soon" toasts with actual OAuth flows:

```typescript
"use client";

import { InfoAccordion } from "@/components/onboarding/info-accordion";
import { OrgOnboardingLayout } from "@/components/onboarding/org-onboarding-layout";
import { ProviderCard } from "@/components/onboarding/provider-card";
import { useOrganization } from "@/hooks/use-organization";
import { getAsanaAuthUrl, getClickUpAuthUrl, getLinearAuthUrl } from "@/lib/api/tasks";
import Image from "next/image";
import { useRouter, useSearchParams } from "next/navigation";
import { useCallback, useEffect, useState } from "react";
import { toast } from "sonner";

const ConnectTaskPage = () => {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { organization } = useOrganization();

  // Loading states
  const [loading, setLoading] = useState({
    asana: false,
    clickup: false,
    linear: false,
  });

  const organizationId = organization?.id;

  // Get current redirect URL for OAuth callback
  const getRedirectUrl = useCallback(() => {
    if (typeof window !== "undefined") {
      return `${window.location.origin}/onboarding/connect-task`;
    }
    return "/onboarding/connect-task";
  }, []);

  // Handle OAuth callback status from URL parameters
  useEffect(() => {
    const success = searchParams.get("success");
    const error = searchParams.get("error");
    const provider = searchParams.get("provider");
    const message = searchParams.get("message");

    if (success === "true") {
      const providerName =
        provider === "asana"
          ? "Asana"
          : provider === "clickup"
            ? "ClickUp"
            : provider === "linear"
              ? "Linear"
              : "Task provider";
      toast.success(`${providerName} connected successfully!`);
      // Clear query params from URL
      router.replace("/onboarding/connect-task", { scroll: false });
    } else if (error) {
      const errorMessage = message || "Failed to connect task provider";
      toast.error(errorMessage);
      // Clear query params from URL
      router.replace("/onboarding/connect-task", { scroll: false });
    }
  }, [searchParams, router]);

  const handleSkip = () => {
    router.push("/onboarding/configure-governance");
  };

  const handleNext = () => {
    router.push("/onboarding/configure-governance");
  };

  const handleConnectAsana = async () => {
    if (!organizationId) {
      toast.error("Please complete organization setup first");
      return;
    }

    setLoading((prev) => ({ ...prev, asana: true }));

    try {
      const redirectUrl = getRedirectUrl();
      const { url } = await getAsanaAuthUrl(organizationId, redirectUrl);
      window.location.href = url;
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "Failed to connect Asana");
      setLoading((prev) => ({ ...prev, asana: false }));
    }
  };

  const handleConnectClickUp = async () => {
    if (!organizationId) {
      toast.error("Please complete organization setup first");
      return;
    }

    setLoading((prev) => ({ ...prev, clickup: true }));

    try {
      const redirectUrl = getRedirectUrl();
      const { url } = await getClickUpAuthUrl(organizationId, redirectUrl);
      window.location.href = url;
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "Failed to connect ClickUp");
      setLoading((prev) => ({ ...prev, clickup: false }));
    }
  };

  const handleConnectLinear = async () => {
    if (!organizationId) {
      toast.error("Please complete organization setup first");
      return;
    }

    setLoading((prev) => ({ ...prev, linear: true }));

    try {
      const redirectUrl = getRedirectUrl();
      const { url } = await getLinearAuthUrl(organizationId, redirectUrl);
      window.location.href = url;
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "Failed to connect Linear");
      setLoading((prev) => ({ ...prev, linear: false }));
    }
  };

  // Info accordion items for what we'll import (TASK-06)
  const importItems = [
    { text: "Task creation and completion dates" },
    { text: "Task status and assignee information" },
    { text: "Time tracking data (Asana and ClickUp)" },
    { text: "Story point estimates (Linear)" },
    { text: "Project and workspace organization" },
  ];

  return (
    <OrgOnboardingLayout
      title="Connect Task Management"
      description="Sync tasks and projects to track work alongside meetings"
      onSkip={handleSkip}
      onNext={handleNext}
    >
      {/* Provider cards grid */}
      <div className="grid grid-cols-1 gap-4 md:grid-cols-3">
        <ProviderCard
          icon={
            <Image
              src="/images/onboarding/tasks/asana.svg"
              alt="Asana"
              width={48}
              height={48}
            />
          }
          name="Asana"
          description="Sync tasks and projects with time tracking data"
          onConnect={handleConnectAsana}
          loading={loading.asana}
        />
        <ProviderCard
          icon={
            <Image
              src="/images/onboarding/tasks/clickup.svg"
              alt="ClickUp"
              width={48}
              height={48}
            />
          }
          name="ClickUp"
          description="Sync tasks, lists, and time tracking data"
          onConnect={handleConnectClickUp}
          loading={loading.clickup}
        />
        <ProviderCard
          icon={
            <Image
              src="/images/onboarding/tasks/linear.svg"
              alt="Linear"
              width={48}
              height={48}
            />
          }
          name="Linear"
          description="Sync issues with status and estimate points"
          onConnect={handleConnectLinear}
          loading={loading.linear}
        />
      </div>

      {/* Info accordion - explains what data will be imported (TASK-06) */}
      <InfoAccordion title="What we'll import" items={importItems} />
    </OrgOnboardingLayout>
  );
};

export default ConnectTaskPage;
```

Key changes:
- Added loading states for each provider
- Imported API functions from tasks.ts
- OAuth handlers call API to get auth URL, then redirect
- Handle OAuth callback status from URL params (success/error)
- Updated InfoAccordion to clarify time tracking (Asana/ClickUp) vs estimates (Linear)
  </action>
  <verify>
```bash
cd apps/web && npx tsc --noEmit src/components/pages/onboarding/connect-task/index.tsx
```
  </verify>
  <done>Connect-task page with working OAuth flows and "What we'll import" explanation</done>
</task>

</tasks>

<verification>
- [ ] Task repository compiles: `cd apps/api && npx tsc --noEmit src/repositories/task.repository.ts`
- [ ] Task sync service compiles: `cd apps/api && npx tsc --noEmit src/services/task-sync.service.ts`
- [ ] Frontend API client compiles: `cd apps/web && npx tsc --noEmit src/lib/api/tasks.ts`
- [ ] Connect-task page compiles: `cd apps/web && npx tsc --noEmit src/components/pages/onboarding/connect-task/index.tsx`
- [ ] Services exported: `grep "task-sync" apps/api/src/services/index.ts`
- [ ] Repository exported: `grep "task.repository" apps/api/src/repositories/index.ts`
</verification>

<success_criteria>
1. Tasks are stored in Firestore with normalized fields
2. Bulk upsert handles large initial syncs efficiently
3. Time tracking captured for Asana (actual_time_minutes) and ClickUp (time_spent)
4. Linear estimates stored as estimatePoints (not time)
5. InfoAccordion explains what data will be imported (TASK-06)
6. Connect buttons trigger OAuth flows (not "coming soon" toasts)
7. OAuth callback shows success/error toast notifications
</success_criteria>

<output>
After completion, create `.planning/phases/07-task-management-integration/07-03-SUMMARY.md`
</output>
