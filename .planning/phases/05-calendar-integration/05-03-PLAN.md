---
phase: 05-calendar-integration
plan: 03
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - apps/api/src/services/google-calendar.service.ts
  - apps/api/src/services/microsoft-calendar.service.ts
  - apps/api/src/services/webhook-handler.service.ts
  - apps/api/src/services/index.ts
  - apps/api/src/routes/webhooks/google.webhook.ts
  - apps/api/src/routes/webhooks/microsoft.webhook.ts
  - apps/api/src/routes/oauth/google.ts
  - apps/api/src/routes/oauth/microsoft.ts
  - apps/api/src/functions/calendar-poll.function.ts
  - apps/api/src/functions/webhook-renew.function.ts
  - apps/api/src/functions/index.ts
  - apps/web/src/components/pages/onboarding/connect-calendar/index.tsx
  - apps/web/src/lib/api/integrations.ts
autonomous: true
requirements: [CAL-04, CAL-05, CAL-06]

must_haves:
  truths:
    - "System creates webhook subscription when calendar is connected"
    - "Webhook notifications trigger incremental sync"
    - "Scheduled polling catches events that webhooks missed"
    - "Webhook channels are renewed before expiration"
    - "User can click Connect button and be redirected to OAuth flow"
    - "User sees clear explanation of what will and won't be tracked before connecting"
  artifacts:
    - path: "apps/api/src/services/webhook-handler.service.ts"
      provides: "Processes queued webhook notifications"
      exports: ["webhookHandlerService"]
    - path: "apps/api/src/functions/calendar-poll.function.ts"
      provides: "Scheduled polling fallback for missed webhooks"
      exports: ["calendarPollFunction"]
    - path: "apps/api/src/functions/webhook-renew.function.ts"
      provides: "Automated webhook channel renewal"
      exports: ["webhookRenewFunction"]
    - path: "apps/web/src/lib/api/integrations.ts"
      provides: "Frontend API client for OAuth flows"
      exports: ["getGoogleAuthUrl", "getMicrosoftAuthUrl"]
    - path: "apps/web/src/components/onboarding/info-accordion.tsx"
      provides: "InfoAccordion component for privacy explanations (from Phase 3)"
      exists: true
  key_links:
    - from: "apps/api/src/routes/webhooks/google.webhook.ts"
      to: "apps/api/src/services/webhook-handler.service.ts"
      via: "processGoogleNotification for queued events"
      pattern: "webhookHandlerService\\.processGoogleNotification"
    - from: "apps/web/src/components/pages/onboarding/connect-calendar/index.tsx"
      to: "apps/web/src/lib/api/integrations.ts"
      via: "getGoogleAuthUrl/getMicrosoftAuthUrl calls"
      pattern: "get(Google|Microsoft)AuthUrl"
    - from: "apps/api/src/functions/calendar-poll.function.ts"
      to: "apps/api/src/services/calendar-sync.service.ts"
      via: "incrementalSync for polling"
      pattern: "calendarSyncService\\.incrementalSync"
    - from: "apps/web/src/components/pages/onboarding/connect-calendar/index.tsx"
      to: "apps/web/src/components/onboarding/info-accordion.tsx"
      via: "InfoAccordion usage for tracking explanations"
      pattern: "InfoAccordion.*What we"
---

<objective>
Implement webhook registration for real-time updates, webhook handlers that process notifications, polling fallback for reliability, and wire the frontend to trigger OAuth flows.

Purpose: Complete the real-time sync infrastructure so calendar changes appear quickly, with polling as a safety net.
Output: Full end-to-end calendar integration with UI wiring, webhooks, and fallback polling.
</objective>

<execution_context>
@/Users/ardiansyahiqbal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ardiansyahiqbal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-calendar-integration/05-RESEARCH.md
@.planning/phases/05-calendar-integration/05-01-SUMMARY.md

@apps/api/src/services/google-calendar.service.ts
@apps/api/src/services/microsoft-calendar.service.ts
@apps/api/src/routes/webhooks/google.webhook.ts
@apps/api/src/routes/webhooks/microsoft.webhook.ts
@apps/api/src/services/webhook-queue.service.ts
@apps/web/src/components/pages/onboarding/connect-calendar/index.tsx
@apps/web/src/components/onboarding/info-accordion.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add webhook registration to calendar services</name>
  <files>
    apps/api/src/services/google-calendar.service.ts
    apps/api/src/services/microsoft-calendar.service.ts
    apps/api/src/routes/oauth/google.ts
    apps/api/src/routes/oauth/microsoft.ts
  </files>
  <action>
    Update `apps/api/src/services/google-calendar.service.ts`:

    1. Add method registerWebhook(accessToken: string, organizationId: string, integrationId: string): Promise<{ channelId: string; resourceId: string; expiration: string }>
       - Use calendar.events.watch API
       - Generate unique channelId: crypto.randomUUID()
       - Create channelToken: `${organizationId}:${crypto.randomBytes(16).toString('hex')}`
       - Webhook URL: `${process.env.API_URL}/api/webhooks/google`
       - Expiration: 7 days from now (Google may return less)
       - Return channelId, resourceId, and actual expiration from response

    2. Add method stopWebhook(accessToken: string, channelId: string, resourceId: string): Promise<void>
       - Use channels.stop API to unsubscribe

    Update `apps/api/src/services/microsoft-calendar.service.ts`:

    1. Add method registerWebhook(accessToken: string, organizationId: string, integrationId: string): Promise<{ subscriptionId: string; expiration: string }>
       - Use Graph /subscriptions API
       - changeType: 'created,updated,deleted'
       - notificationUrl: `${process.env.API_URL}/api/webhooks/microsoft`
       - resource: 'me/events'
       - clientState: `${organizationId}:${crypto.randomBytes(16).toString('hex')}`
       - expirationDateTime: 3 days from now (Microsoft calendar max is ~7 days)
       - Return subscriptionId and expiration

    2. Add method renewWebhook(accessToken: string, subscriptionId: string): Promise<{ expiration: string }>
       - PATCH /subscriptions/{id} with new expirationDateTime

    3. Add method deleteWebhook(accessToken: string, subscriptionId: string): Promise<void>
       - DELETE /subscriptions/{id}

    Update OAuth callback handlers (google.ts, microsoft.ts):
    - After integrationService.connect() and before triggerInitialSync:
    - Call appropriate registerWebhook method
    - Update integration with webhookChannelId/subscriptionId
    - Update sync state with webhook expiration

    Note: Store webhookSecret (the token/clientState) encrypted in integration for verification
  </action>
  <verify>
    `cd apps/api && pnpm build` succeeds
    `grep "registerWebhook" apps/api/src/services/google-calendar.service.ts` exists
    `grep "registerWebhook" apps/api/src/services/microsoft-calendar.service.ts` exists
  </verify>
  <done>
    Google calendar.events.watch creates webhook subscription
    Microsoft /subscriptions creates webhook subscription
    Webhook registered during OAuth callback after token storage
    Webhook secrets stored encrypted for verification
  </done>
</task>

<task type="auto">
  <name>Task 2: Create webhook handler service and update webhook routes</name>
  <files>
    apps/api/src/services/webhook-handler.service.ts
    apps/api/src/services/index.ts
    apps/api/src/routes/webhooks/google.webhook.ts
    apps/api/src/routes/webhooks/microsoft.webhook.ts
    apps/api/src/functions/webhook-renew.function.ts
    apps/api/src/functions/calendar-poll.function.ts
    apps/api/src/functions/index.ts
  </files>
  <action>
    Create `apps/api/src/services/webhook-handler.service.ts`:

    1. Import calendarSyncService, integrationRepository, syncStateRepository

    2. Methods:
       - async processGoogleNotification(queueItem: WebhookQueueItem): Promise<void>
         - Extract organizationId from channel token
         - Find integration by webhookChannelId
         - Verify webhookSecret matches token
         - Trigger incrementalSync (Google notifications just signal "something changed")

       - async processMicrosoftNotification(queueItem: WebhookQueueItem): Promise<void>
         - Extract organizationId from clientState
         - Find integration by subscriptionId
         - Verify secret matches
         - Trigger incrementalSync

       - async processQueuedNotifications(): Promise<{ processed: number; failed: number }>
         - Fetch pending items from webhook queue
         - Process each based on provider
         - Mark as processed or retry

    Export webhookHandlerService singleton

    Update webhook routes to verify secrets:
    - google.webhook.ts: After queuing, optionally trigger immediate processing
    - microsoft.webhook.ts: Same pattern

    Create `apps/api/src/functions/webhook-renew.function.ts`:
    - Scheduled function (every 12 hours)
    - Find sync states with webhook expiration < 24 hours from now
    - For each, call renewWebhook (Microsoft) or re-register (Google doesn't support renew)
    - Update sync state with new expiration

    Create `apps/api/src/functions/calendar-poll.function.ts`:
    - Scheduled function (every 15 minutes)
    - Find all connected calendar integrations
    - For each, call incrementalSync
    - This catches any events webhooks missed

    Create `apps/api/src/functions/index.ts` to export both functions

    Export webhookHandlerService from apps/api/src/services/index.ts
  </action>
  <verify>
    `cd apps/api && pnpm build` succeeds
    `grep "processGoogleNotification" apps/api/src/services/webhook-handler.service.ts` exists
    `grep "calendarPollFunction" apps/api/src/functions/index.ts` exists
  </verify>
  <done>
    Webhook handler processes queued notifications and triggers sync
    Webhook renewal scheduled before expiration
    Polling fallback runs every 15 minutes
    Both provide reliability for real-time updates
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire frontend Connect buttons to OAuth flow with callback handling</name>
  <files>
    apps/web/src/lib/api/integrations.ts
    apps/web/src/components/pages/onboarding/connect-calendar/index.tsx
  </files>
  <action>
    PREREQUISITE CHECK (CAL-06):
    Before implementing, verify InfoAccordion exists and is used correctly:
    - File must exist: apps/web/src/components/onboarding/info-accordion.tsx
    - ConnectCalendar must import and use InfoAccordion with "What we'll track" and "What we don't track"
    - If missing: create InfoAccordion component first (see Phase 3 patterns)

    Create `apps/web/src/lib/api/integrations.ts`:

    1. Import apiClient from existing @/lib/api (or create if needed)

    2. Functions:
       - async getGoogleAuthUrl(organizationId: string): Promise<{ url: string }>
         - GET /api/oauth/google/authorize?organizationId={organizationId}
         - Returns authorization URL

       - async getMicrosoftAuthUrl(organizationId: string): Promise<{ url: string }>
         - GET /api/oauth/microsoft/authorize?organizationId={organizationId}
         - Returns authorization URL

       - async getIntegrations(organizationId: string): Promise<Integration[]>
         - GET /api/integrations?organizationId={organizationId}
         - Returns list of connected integrations

       - async disconnectIntegration(integrationId: string): Promise<void>
         - DELETE /api/integrations/{integrationId}

    Update `apps/web/src/components/pages/onboarding/connect-calendar/index.tsx`:

    1. Import getGoogleAuthUrl, getMicrosoftAuthUrl, getIntegrations
    2. Import useSearchParams from next/navigation

    3. State:
       - integrations: Integration[] (fetched on mount)
       - loading: { google: boolean, microsoft: boolean }
       - connected: { google: boolean, microsoft: boolean }

    4. Add useEffect for OAuth callback status handling:
       ```typescript
       const searchParams = useSearchParams();

       useEffect(() => {
         const status = searchParams.get('status');
         const provider = searchParams.get('provider');

         if (status === 'success') {
           toast.success(`${provider || 'Calendar'} connected successfully!`);
           // Clear query params from URL
           router.replace('/onboarding/connect-calendar', { scroll: false });
         } else if (status === 'error') {
           const message = searchParams.get('message') || 'Failed to connect calendar';
           toast.error(message);
           router.replace('/onboarding/connect-calendar', { scroll: false });
         }
       }, [searchParams, router]);
       ```

    5. Add useEffect to fetch existing integrations and set connected state on mount

    6. Update handleConnectGoogle:
       - Set loading.google = true
       - Call getGoogleAuthUrl(organizationId)
       - window.location.href = response.url (redirect to OAuth)

    7. Update handleConnectMicrosoft:
       - Set loading.microsoft = true
       - Call getMicrosoftAuthUrl(organizationId)
       - window.location.href = response.url

    8. Update ProviderCard rendering:
       - If connected, show "Connected" badge with account email
       - If not connected, show Connect button
       - Show loading spinner while redirecting

    9. Get organizationId from session/context (use existing auth pattern)

    10. VERIFY InfoAccordion usage preserved:
        - Keep existing InfoAccordion components for "What we'll track" and "What we don't track"
        - Do NOT remove these - they satisfy CAL-06
  </action>
  <verify>
    `cd apps/web && pnpm build` succeeds
    `grep "getGoogleAuthUrl" apps/web/src/lib/api/integrations.ts` exists
    `grep "handleConnectGoogle" apps/web/src/components/pages/onboarding/connect-calendar/index.tsx` shows implementation
    `grep "useSearchParams" apps/web/src/components/pages/onboarding/connect-calendar/index.tsx` shows callback handling
    `grep "InfoAccordion" apps/web/src/components/pages/onboarding/connect-calendar/index.tsx` shows CAL-06 coverage
  </verify>
  <done>
    Connect buttons redirect to OAuth flow
    OAuth callback status (success/error) handled via useSearchParams and shows toast
    Connected integrations display account email
    InfoAccordion remains in place showing "What we'll track" / "What we don't track" (CAL-06)
    Frontend fully wired to backend OAuth endpoints
  </done>
</task>

</tasks>

<verification>
1. API build passes: `cd apps/api && pnpm build`
2. Web build passes: `cd apps/web && pnpm build`
3. Functions exported: `grep -E "(calendarPollFunction|webhookRenewFunction)" apps/api/src/functions/index.ts`
4. Frontend connects to OAuth: Check connect-calendar/index.tsx imports integrations API
5. Callback handling: `grep "useSearchParams" apps/web/src/components/pages/onboarding/connect-calendar/index.tsx`
6. CAL-06 verification: `grep -A2 "InfoAccordion" apps/web/src/components/pages/onboarding/connect-calendar/index.tsx` shows "What we'll track"
</verification>

<success_criteria>
- Webhook subscriptions created during OAuth callback for both providers
- Webhook notifications trigger incremental calendar sync
- Polling fallback runs every 15 minutes as reliability backup
- Webhook channels renewed before expiration
- Connect buttons redirect to OAuth and show connected state after
- OAuth callback status (success/error) displayed via toast notification
- User sees account email after successful connection
- CAL-06 verified: InfoAccordion shows "What we'll track" and "What we don't track" (from Phase 3, verified exists)
</success_criteria>

<output>
After completion, create `.planning/phases/05-calendar-integration/05-03-SUMMARY.md`
</output>
