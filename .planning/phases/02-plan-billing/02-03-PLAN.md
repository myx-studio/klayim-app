---
phase: 02-plan-billing
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/routes/webhook.route.ts
  - apps/api/src/routes/index.ts
  - apps/api/src/services/webhook.service.ts
  - apps/api/src/services/index.ts
  - apps/api/src/repositories/processed-event.repository.ts
  - apps/api/src/repositories/index.ts
  - apps/api/src/index.ts
  - packages/shared/src/types/organization.ts
autonomous: true
requirements: [BILL-04, BILL-05]

user_setup:
  - service: stripe
    why: "Webhook signature verification"
    env_vars:
      - name: STRIPE_WEBHOOK_SECRET
        source: "Stripe Dashboard -> Developers -> Webhooks -> Signing secret (whsec_xxx)"
    dashboard_config:
      - task: "Create webhook endpoint pointing to your API"
        location: "Stripe Dashboard -> Developers -> Webhooks -> Add endpoint"
        details: "URL: https://your-api-domain/webhooks/stripe, Events: checkout.session.completed, invoice.paid, invoice.payment_failed, customer.subscription.deleted"

must_haves:
  truths:
    - "Webhook endpoint receives Stripe events and verifies signatures"
    - "checkout.session.completed event updates organization with subscription data"
    - "Duplicate webhook events are handled idempotently"
    - "Payment failure events are logged for future alerting"
  artifacts:
    - path: "apps/api/src/routes/webhook.route.ts"
      provides: "Stripe webhook endpoint"
      exports: ["webhookRoutes"]
    - path: "apps/api/src/services/webhook.service.ts"
      provides: "Webhook event processing logic"
      exports: ["webhookService"]
    - path: "apps/api/src/repositories/processed-event.repository.ts"
      provides: "Idempotency tracking"
      exports: ["processedEventRepository"]
  key_links:
    - from: "apps/api/src/routes/webhook.route.ts"
      to: "apps/api/src/services/webhook.service.ts"
      via: "service method call"
      pattern: "webhookService\\.processStripeEvent"
    - from: "apps/api/src/services/webhook.service.ts"
      to: "apps/api/src/repositories/processed-event.repository.ts"
      via: "idempotency check"
      pattern: "processedEventRepository\\.findById"
---

<objective>
Create Stripe webhook handler with idempotent event processing

Purpose: Reliably update subscription state when Stripe sends payment events
Output: Webhook endpoint that processes checkout completion, payment success/failure, and cancellation
</objective>

<execution_context>
@/Users/ardiansyahiqbal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ardiansyahiqbal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-plan-billing/02-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Organization Type with Subscription Fields</name>
  <files>
    packages/shared/src/types/organization.ts
  </files>
  <action>
Update organization types in `packages/shared/src/types/organization.ts` to include subscription fields.

Add these types/fields to the existing Organization interface:

```typescript
export type SubscriptionStatus = 'active' | 'trialing' | 'past_due' | 'canceled' | 'expired';

export interface ActivePlan {
  planType: 'individual' | 'team' | 'enterprise';
  status: SubscriptionStatus;
  stripeSubscriptionId?: string;
  stripeCustomerId?: string;
  currentPeriodStart?: string; // ISO date
  currentPeriodEnd?: string;   // ISO date
  cancelAtPeriodEnd?: boolean;
}

// Add to existing Organization interface:
// stripeCustomerId?: string;
// activePlan?: ActivePlan;
```

If Organization interface doesn't exist yet, create it with these fields. Check existing types first.

Note: The existing codebase may already have some of these fields. Review `packages/shared/src/types/organization.ts` first and only add what's missing.
  </action>
  <verify>
Run `cd /Users/ardiansyahiqbal/dev-app/myx/klayim && pnpm build --filter @klayim/shared` to verify types compile.
  </verify>
  <done>
Organization type includes stripeCustomerId and activePlan fields.
SubscriptionStatus and ActivePlan types exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Processed Event Repository for Idempotency</name>
  <files>
    apps/api/src/repositories/processed-event.repository.ts
    apps/api/src/repositories/index.ts
  </files>
  <action>
Create processed event repository in `apps/api/src/repositories/processed-event.repository.ts`:

```typescript
import { db } from '@/lib/firebase.js';

interface ProcessedEvent {
  id: string;
  type: string;
  processedAt: string;
}

const COLLECTION = 'processed_stripe_events';

class ProcessedEventRepository {
  async findById(eventId: string): Promise<ProcessedEvent | null> {
    const doc = await db.collection(COLLECTION).doc(eventId).get();
    if (!doc.exists) {
      return null;
    }
    return { id: doc.id, ...doc.data() } as ProcessedEvent;
  }

  async create(event: ProcessedEvent): Promise<void> {
    await db.collection(COLLECTION).doc(event.id).set({
      type: event.type,
      processedAt: event.processedAt,
    });
  }
}

export const processedEventRepository = new ProcessedEventRepository();
```

Update `apps/api/src/repositories/index.ts` to export processedEventRepository.
  </action>
  <verify>
Check file exists with correct exports.
Run `cd /Users/ardiansyahiqbal/dev-app/myx/klayim/apps/api && pnpm build` to verify compilation.
  </verify>
  <done>
ProcessedEventRepository created with findById and create methods.
Uses Firestore collection 'processed_stripe_events'.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Webhook Service and Route</name>
  <files>
    apps/api/src/services/webhook.service.ts
    apps/api/src/services/index.ts
    apps/api/src/routes/webhook.route.ts
    apps/api/src/routes/index.ts
    apps/api/src/index.ts
  </files>
  <action>
Create webhook service in `apps/api/src/services/webhook.service.ts`:

```typescript
import type Stripe from 'stripe';
import { processedEventRepository } from '@/repositories/index.js';
import { organizationRepository } from '@/repositories/index.js';
import type { ActivePlan, SubscriptionStatus } from '@klayim/shared/types';

class WebhookService {
  async processStripeEvent(event: Stripe.Event): Promise<void> {
    // Idempotency check
    const existing = await processedEventRepository.findById(event.id);
    if (existing) {
      console.log(`Event ${event.id} already processed, skipping`);
      return;
    }

    switch (event.type) {
      case 'checkout.session.completed':
        await this.handleCheckoutComplete(event.data.object as Stripe.Checkout.Session);
        break;
      case 'invoice.paid':
        await this.handleInvoicePaid(event.data.object as Stripe.Invoice);
        break;
      case 'invoice.payment_failed':
        await this.handlePaymentFailed(event.data.object as Stripe.Invoice);
        break;
      case 'customer.subscription.deleted':
        await this.handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
        break;
      case 'customer.subscription.updated':
        await this.handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
        break;
      default:
        console.log(`Unhandled event type: ${event.type}`);
    }

    // Mark as processed AFTER successful handling
    await processedEventRepository.create({
      id: event.id,
      type: event.type,
      processedAt: new Date().toISOString(),
    });
  }

  private async handleCheckoutComplete(session: Stripe.Checkout.Session): Promise<void> {
    const organizationId = session.metadata?.organizationId;
    if (!organizationId) {
      console.error('No organizationId in checkout session metadata');
      return;
    }

    const subscriptionId = session.subscription as string;
    const customerId = session.customer as string;
    const planType = session.metadata?.planType as 'individual' | 'team';

    const activePlan: ActivePlan = {
      planType,
      status: 'active',
      stripeSubscriptionId: subscriptionId,
      stripeCustomerId: customerId,
    };

    await organizationRepository.update(organizationId, {
      stripeCustomerId: customerId,
      activePlan,
    });

    console.log(`Organization ${organizationId} subscription activated: ${subscriptionId}`);
  }

  private async handleInvoicePaid(invoice: Stripe.Invoice): Promise<void> {
    const subscriptionId = invoice.subscription as string;
    if (!subscriptionId) return;

    // Find organization by subscription ID and update period dates
    // For v1, just log - organization lookup by subscriptionId needs separate method
    console.log(`Invoice paid for subscription: ${subscriptionId}`);
  }

  private async handlePaymentFailed(invoice: Stripe.Invoice): Promise<void> {
    const subscriptionId = invoice.subscription as string;
    console.error(`Payment failed for subscription: ${subscriptionId}`);
    // TODO: Update organization status to past_due, send notification
  }

  private async handleSubscriptionDeleted(subscription: Stripe.Subscription): Promise<void> {
    const organizationId = subscription.metadata?.organizationId;
    if (!organizationId) {
      console.error('No organizationId in subscription metadata');
      return;
    }

    await organizationRepository.update(organizationId, {
      'activePlan.status': 'canceled' as SubscriptionStatus,
    });

    console.log(`Organization ${organizationId} subscription canceled`);
  }

  private async handleSubscriptionUpdated(subscription: Stripe.Subscription): Promise<void> {
    const organizationId = subscription.metadata?.organizationId;
    if (!organizationId) return;

    const status = this.mapStripeStatus(subscription.status);
    const cancelAtPeriodEnd = subscription.cancel_at_period_end;

    await organizationRepository.update(organizationId, {
      'activePlan.status': status,
      'activePlan.cancelAtPeriodEnd': cancelAtPeriodEnd,
      'activePlan.currentPeriodStart': new Date(subscription.current_period_start * 1000).toISOString(),
      'activePlan.currentPeriodEnd': new Date(subscription.current_period_end * 1000).toISOString(),
    });
  }

  private mapStripeStatus(stripeStatus: Stripe.Subscription.Status): SubscriptionStatus {
    switch (stripeStatus) {
      case 'active':
      case 'trialing':
        return stripeStatus;
      case 'past_due':
        return 'past_due';
      case 'canceled':
      case 'unpaid':
        return 'canceled';
      default:
        return 'expired';
    }
  }
}

export const webhookService = new WebhookService();
```

Update `apps/api/src/services/index.ts` to export webhookService.

Create webhook route in `apps/api/src/routes/webhook.route.ts`:

```typescript
import { Hono } from 'hono';
import Stripe from 'stripe';
import { webhookService } from '@/services/index.js';

const webhooks = new Hono();

// POST /webhooks/stripe - Stripe webhook handler
// CRITICAL: No auth middleware - Stripe sends these requests
// CRITICAL: Use text() to get raw body for signature verification
webhooks.post('/stripe', async (c) => {
  const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);
  const signature = c.req.header('stripe-signature');

  if (!signature) {
    console.error('Missing Stripe signature header');
    return c.text('Missing signature', 400);
  }

  // CRITICAL: Must use text() not json() for signature verification
  const body = await c.req.text();

  let event: Stripe.Event;
  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (err: any) {
    console.error('Webhook signature verification failed:', err.message);
    return c.text('Invalid signature', 400);
  }

  // Process webhook - errors logged but always return 200 to prevent retries
  try {
    await webhookService.processStripeEvent(event);
  } catch (err) {
    console.error('Error processing webhook:', err);
    // Still return 200 - error logged for investigation
    // Returning non-200 causes Stripe to retry, which may cause duplicate processing issues
  }

  return c.text('', 200);
});

export { webhooks as webhookRoutes };
```

Update `apps/api/src/routes/index.ts` to export webhookRoutes.

Update `apps/api/src/index.ts` to mount webhook routes:
- Import `webhookRoutes` from routes
- Mount WITHOUT any middleware: `app.route('/webhooks', webhookRoutes)`
- CRITICAL: Webhook routes must NOT have auth middleware or any JSON body parsing middleware

The route should be mounted BEFORE any global middleware that parses JSON bodies.
  </action>
  <verify>
Run `cd /Users/ardiansyahiqbal/dev-app/myx/klayim/apps/api && pnpm build` to verify compilation.
Check that webhook routes are mounted in apps/api/src/index.ts.
  </verify>
  <done>
Webhook route created at POST /webhooks/stripe.
Signature verification implemented using raw body.
Idempotent processing with processed_stripe_events collection.
Handles checkout.session.completed, invoice.paid/failed, subscription.deleted/updated.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes in apps/api
2. `pnpm build` passes in packages/shared
3. Webhook route mounted at /webhooks/stripe
4. No auth middleware on webhook route
5. webhookService exported from services
6. processedEventRepository exported from repositories
</verification>

<success_criteria>
- POST /webhooks/stripe endpoint exists and verifies Stripe signatures
- checkout.session.completed updates organization with subscription data
- Duplicate events are skipped via idempotency check
- Payment failure and cancellation events are logged
- All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-plan-billing/02-03-SUMMARY.md`
</output>
